<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concurrentes - FIUBA</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Concurrentes - FIUBA</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="inicio"><a class="header" href="#inicio">Inicio</a></h1>
<p>Bienvenidos y bienvenidas a la cátedra de <strong>Técnicas de Programación Concurrente I</strong> de la <a href="http://www.fi.uba.ar/">Facultad de Ingeniería</a> - UBA.</p>
<p>Los docentes de la Cátedra son:</p>
<ul>
<li>
<p><strong>Profesor:</strong> Ing. Pablo A. Deymonnaz</p>
</li>
<li>
<p><strong>Jefe de Trabajos Practicos:</strong></p>
<ul>
<li>Ing. Ariel Scarpinelli</li>
</ul>
</li>
<li>
<p><strong>Colaboradores:</strong></p>
<ul>
<li>Nicolás Longo</li>
</ul>
</li>
<li>
<p><strong>Asesores:</strong></p>
<ul>
<li>Dr. Mariano Méndez (asesor académico)</li>
<li>Federico Carrone (asesor de la industria)</li>
<li>Facundo Olano (asesor de la industria)</li>
</ul>
</li>
</ul>
<p>Las clases se desarrollan los días <strong>martes y miércoles de 19 a 22 hs</strong> a través de la plataforma Google Meet, se graban las clases.</p>
<p>Los enlaces para acceder a Meet, así como las grabaciones de clases anteriores, son de acceso exclusivo a los inscriptos a la materia.</p>
<h2 id="materias-correlativas"><a class="header" href="#materias-correlativas">Materias Correlativas</a></h2>
<ul>
<li><a href="https://fisop.github.io/7508/">75.08 Sistemas Operativos</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cronograma-1er-cuatrimestre-2025"><a class="header" href="#cronograma-1er-cuatrimestre-2025">Cronograma 1er cuatrimestre 2025</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Fecha</th><th>Evento</th></tr></thead><tbody>
<tr><td>26 de Marzo</td><td>TP1 - Presentación de enunciado</td></tr>
<tr><td>23 de Abril</td><td>TP1 - Entrega</td></tr>
<tr><td>30 de Abril</td><td>TP2 - Presentación de enunciado</td></tr>
<tr><td>7 de Mayo</td><td><strong>Parcial</strong></td></tr>
<tr><td>28 de Mayo</td><td>TP2 - Pre-entrega.</td></tr>
<tr><td>28 de Mayo</td><td>Recuperatorio de parcial</td></tr>
<tr><td>17 de Junio</td><td>TP2 - Entrega Final</td></tr>
<tr><td>17, 18, 24 y 25 de Junio</td><td>TP2 - Presentaciones</td></tr>
<tr><td>1 de Julio</td><td>2do recuperatorio de parcial</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="clases"><a class="header" href="#clases">Clases</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Semana</th><th>Teorica</th><th>Práctica</th></tr></thead><tbody>
<tr><td>1</td><td><a href="./clases/1-introduccion.pdf">Introducción a Concurrencia</a></td><td><a href="./clases/1-practica-intro-rust.pdf">Introducción a Rust</a></td></tr>
<tr><td>2</td><td><a href="./clases/2-fork-join.pdf">Modelo Fork Join</a></td><td><a href="./clases/2-practica-forkjoin.pdf">Práctica sobre Fork Join</a></td></tr>
<tr><td>3</td><td><a href="./clases/3-async.pdf">Programación Asincrónica</a></td><td><a href="./clases/3-practica-async.pdf">Práctica sobre Programación Asincrónica</a> <br/> <a href="./clases/3-practica-vectorizacion.pdf">Vectorización</a></td></tr>
<tr><td>4</td><td><a href="./clases/4-correccion.pdf">Corrección / Sección Crítica / Locks</a></td><td><a href="./clases/4-practica-threads-locks.pdf">Práctica sobre Locks</a></td></tr>
<tr><td>5</td><td><a href="./clases/5-sincronizacion.pdf">Sincronización / Semáforos y Barreras</a> <br/> <a href="./clases/5-monitores.pdf">Monitores</a></td><td><a href="./clases/5-practica-sincronizacion.pdf">Práctica sobre Sincronizacion</a></td></tr>
<tr><td>6</td><td><a href="./clases/6-petri.pdf">Redes de Petri</a></td><td><a href="./clases/6-practica-petri.pdf">Práctica sobre Redes de Petri</a></td></tr>
<tr><td>7</td><td><a href="./clases/7-mensajes-channels.pdf">Pasaje de Mensajes / Canales</a> <br/> <a href="./clases/7-actores.pdf">Actores</a></td><td><a href="./clases/7-practica-actores.pdf">Práctica Channels y Actores</a></td></tr>
<tr><td>8</td><td><a href="./clases/8-distrib.pdf">Concurrencia Distribuida: Algoritmos de Exclusión Mutua - Repaso de Redes. Sockets en UNIX</a></td><td><a href="./clases/8-practica-sockets.pdf">Práctica sobre Sockets y Exclusión Mutua distribuida</a></td></tr>
<tr><td>9</td><td><a href="./clases/9-distrib2.pdf">Concurrencia Distribuida (parte 2): Algoritmos de Elección - Sockets en Rust</a></td><td><a href="./clases/9-practica-lider.pdf">Práctica de Algoritmos de Elección</a></td></tr>
<tr><td>10</td><td><a href="./clases/10-distrib3.pdf">Concurrencia Distribuida (parte 3): Transacciones - Deadlocks</a></td><td><a href="./clases/10-practica-transacciones-distribuidas.pdf">Práctica de Transacciones Distribuidas</a></td></tr>
<tr><td>11</td><td><a href="./clases/11-ambientes-distrib.pdf">Ambientes Distribuidos</a></td><td><a href="./clases/10-practica-transacciones-distribuidas.pdf">Práctica de Transacciones Distribuidas</a></td></tr>
<tr><td>Especiales</td><td><a href="./clases/x-practica-lenguajes.pdf">Lenguajes para concurrencia</a></td><td><a href="./clases/x-practica-testing.pdf">Taller de Testing</a></td></tr>
<tr><td></td><td><a href="./clases/x-practica-cuda.pdf">CUDA</a></td><td></td></tr>
</tbody></table>
</div>
<h2 id="ejemplos"><a class="header" href="#ejemplos">Ejemplos</a></h2>
<p><a href="https://github.com/concurrentes-fiuba/ejemplos-concurrentes">Repositorio de ejemplos</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1er-cuatrimestre-2024"><a class="header" href="#1er-cuatrimestre-2024">1er Cuatrimestre 2024</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico"><a class="header" href="#trabajo-práctico">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong>
<em>23 de Abril</em></p>
<h2 id="introducción"><a class="header" href="#introducción">Introducción</a></h2>
<p>Steam es una plataforma de distribución digital de videojuegos.</p>
<p>Publica una API para obtener, entre otras cosas, los reviews que los usuarios publican sobre estos juegos. https://partner.steamgames.com/doc/store/getreviews</p>
<p>Queremos analizar un dataset con dumps de estos reviews par encontrar los juegos mejor calificados, y las caracteristicas de su comunidad.</p>
<p>Dicho dataset se encuentra publicado en Kaggle, en formato CSV donde cada linea correspodne a una reseña hecha por un usuario sobre un juego.</p>
<h2 id="objetivo"><a class="header" href="#objetivo">Objetivo</a></h2>
<p>Implementar una aplicación en Rust para procesamiento de información, aprovechando las ventajas del modelo Fork-Join,
utilizando el dataset <a href="https://www.kaggle.com/datasets/najzeko/steam-reviews-2021">https://www.kaggle.com/datasets/najzeko/steam-reviews-2021</a></p>
<p>La información a obtener del mismo incluye:</p>
<ul>
<li>
<p>El top 10 de juegos con más reseñas (campo <code>app_name</code>). En caso de empate, resolver alfabeticamente.</p>
<ul>
<li>De cada juego, la cantidad reseñas que obtuvo.</li>
<li>Los 3 idiomas más utilizados para hacer reseñas del juego, junto con la cantidad de reseñas en ese idioma. En caso de empate, resolver alfabeticamente.
<ul>
<li>Y por cada idioma, el texto de la reseña más votada (<code>votes_helpful</code>) con su cantidad de votos.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>El top 3 de idiomas utilizados para hacer reseñas (campo <code>language</code>). En caso de empate, resolver alfabeticamente.</p>
<ul>
<li>De cada idioma, la cantidad total de reseñas escritas en ese idioma.</li>
<li>El top 10 de reseñas más votadas en ese idioma junto con la cantidad de votos.</li>
</ul>
</li>
</ul>
<h2 id="requerimientos"><a class="header" href="#requerimientos">Requerimientos</a></h2>
<ul>
<li>La aplicación debe recibir como parámetro de linea de comandos el path a un directorio, y debe procesar todos los
archivos <code>.csv</code> en el mismo. Los archivos a procesar corresponden con el formato del archivo <code>stream_reviews.csv</code> dentro del dataset.</li>
<li>Debe recibir un segundo parámetro entero por linea de comandos indicando la cantidad de worker threads con la cual procesar la información</li>
<li>Debe recibir un tercer parámetro con el nombre del archivo de salida como resultado del procesamiento.</li>
</ul>
<p>En resumen, la aplicación será ejecutada como <code>cargo run &lt;input-path&gt; &lt;num-threads&gt; &lt;output-file-name&gt;</code></p>
<ul>
<li>El formato del archivo de salida debe ser</li>
</ul>
<pre><code>{
    "padron": &lt;número de padron del alumno&gt;,
    "top_games": [{
        "game": "&lt;nombre juego 1&gt;",
        "review_count": &lt;cantidad total reseñas para ese juego&gt;
        "languages": [
          {
            "language": "&lt;nombre idioma 1&gt;",
            "review_count": "&lt;cantidad de reseñas para ese juego en ese idioma&gt;"
            "top_review": "&lt;texto del comentario mas votado&gt;",
            "top_review_votes": &lt;cantidad de votos que recibio el comentario mas votado&gt;
          },
          ...,
          {
            "language": "&lt;nombre idioma 3&gt;",
            ...
          },
        ]
      },
      ...,
      {
        "game": "&lt;nombre juego 10&gt;",
        ...
      }],
    "top_languages": [{
        {
          "language": "&lt;nombre idioma 1&gt;"
          "review_count": &lt;cantidad total reseñas para ese juego&gt;,
          "top_reviews": [{
            "review": "&lt;texto de la reseña mas votada&gt;",
            "votes": cantidad de votos que obtuvo
          },
          ...,
          {
            "review": "&lt;texto de la reseña N&gt;",
            ...
          }]
        },
        ...
        {
          "language": "&lt;nombre idioma 3&gt;"
          ...
        },
    }]
}
</code></pre>
<h2 id="requerimientos-no-funcionales"><a class="header" href="#requerimientos-no-funcionales">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>El archivo Cargo.toml se debe encontrar en la raíz del repositorio, para poder ejecutar correctamente los tests automatizados</li>
<li>Se deberán utilizar las herramientas de concurrencia correspondientes al modelo forkjoin</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados en este enunciado, en los ejemplos de la materia, o autorizados expresamente por los profesores. Para el procesamiento de JSON se puede utilizar el crate <code>serde_json</code>.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega"><a class="header" href="#entrega">Entrega</a></h2>
<p>La resolución del presente proyecto es individual.</p>
<p>La entrega del proyecto se realizará mediante Github Classroom. Cada estudiante tendrá un repositorio disponible para hacer diferentes commits con el objetivo de resolver el problema propuesto. Se recomienda iniciar tempranamente y hacer commits pequeños agreguen funcionalidad incrementalmente.</p>
<p>Se podrán hacer commits hasta el día de la entrega a las 19 hs Arg, luego el sistema automáticamente quitará el acceso de escritura.</p>
<p>El archivo README.md en el repositorio debe incluir el padrón del alumno y un enlace a un video de entre 5 y 7 minutos donde el alumno explique su resolución, detallando las decisiones de diseño y mostrando en vivo el código que escribió. El video debe mostrar claramente la cara del alumno y se debe poder escuchar correctamente y con buen volumen su voz.</p>
<h2 id="evaluación"><a class="header" href="#evaluación">Evaluación</a></h2>
<h3 id="principios-teóricos-y-corrección-de-bugs"><a class="header" href="#principios-teóricos-y-corrección-de-bugs">Principios teóricos y corrección de bugs</a></h3>
<p>La evaluación se realizará sobre Github, pudiendo el profesor hacer comentarios en el repositorio y solicitar cambios
o mejoras cuando lo encuentre oportuno, especialmente debido al uso incorrecto de herramientas de concurrencia.</p>
<h3 id="casos-de-prueba"><a class="header" href="#casos-de-prueba">Casos de prueba</a></h3>
<p>Se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de
concurrencia, por ejemplo, la ausencia de deadlocks.</p>
<p>Además la aplicación deberá respetar los formatos de salida y valores esperados de los resultados, y deberá mostrar algún
incremento en performance cuando la ejecución de la misma se hace con varios hilos en un ambiente multiprocesador.</p>
<h3 id="organización-del-código"><a class="header" href="#organización-del-código">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust. Se prohibe el uso de bloques <code>unsafe</code>.</p>
<h3 id="tests-automatizados"><a class="header" href="#tests-automatizados">Tests automatizados</a></h3>
<p>La presencia de tests automatizados que prueben diferentes casos, en especial sobre el uso de las herramientas de concurrencia es un plus.</p>
<h3 id="presentación-en-término"><a class="header" href="#presentación-en-término">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influye negativamente en la nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2do-cuatrimestre-2024"><a class="header" href="#2do-cuatrimestre-2024">2do Cuatrimestre 2024</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-1"><a class="header" href="#trabajo-práctico-1">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong>
<em>18 de Septiembre</em></p>
<h2 id="introducción-1"><a class="header" href="#introducción-1">Introducción</a></h2>
<p>PUBG es un juego de disparos en primera y tercera persona estilo Battle Royale que enfrenta a más de 90 jugadores en una
gran isla donde los equipos y los jugadores luchan a muerte hasta que queda uno.</p>
<p>El sitio pubg.op.gg publica estadísticas sobre este juego.</p>
<p>Queremos analizar un dataset con dumps de este sitio para mejorar las estrategias de juego.</p>
<h2 id="objetivo-1"><a class="header" href="#objetivo-1">Objetivo</a></h2>
<p>Implementar una aplicación en Rust para procesamiento de información, aprovechando las ventajas del modelo Fork-Join,
utilizando el dataset <a href="https://www.kaggle.com/datasets/skihikingkevin/pubg-match-deaths">https://www.kaggle.com/datasets/skihikingkevin/pubg-match-deaths</a></p>
<p>La información a obtener del mismo incluye:</p>
<ul>
<li>El top 10 de armas (campo <code>killed_by</code>) que produjeron la mayor cantidad de muertes. En caso de empate, resolver alfabeticamente.
<ul>
<li>De cada arma, el % del total de muertes que produjo, redondeado a dos decimales.</li>
<li>El promedio de distancia entre el asesino y la víctima para esa arma (<code>((killer_position_x - victim_position_x).powi(2) + (killer_position_y - victim_position_y).powi(2)).sqrt()</code>; , redondeado a dos decimales.</li>
</ul>
</li>
<li></li>
<li>EL top 10 de jugadores (campo <code>killer_name</code>) que produjeron la mayor cantidad de muertes. En caso de empate, resolver alfabeticamente.
<ul>
<li>De cada jugador, el total de muertes que produjo.</li>
<li>El top 3 de armas mas utilizadas por el jugador, junto con su % de uso respecto del total de muertes ocasionadas por ese jugador, redondeado a dos decimales. En caso de empate, resolver alfabeticamente.</li>
</ul>
</li>
</ul>
<h2 id="requerimientos-1"><a class="header" href="#requerimientos-1">Requerimientos</a></h2>
<ul>
<li>La aplicación debe recibir como parámetro de linea de comandos el path a un directorio, y debe procesar todos los
archivos <code>.csv</code> en el mismo. Los archivos a procesar corresponden con el formato del directorio <code>deaths</code> dentro del dataset.</li>
<li>Debe recibir un segundo parámetro entero por linea de comandos indicando la cantidad de worker threads con la cual procesar la información</li>
<li>Debe recibir un tercer parámetro con el nombre del archivo de salida como resultado del procesamiento.</li>
</ul>
<p>En resumen, la aplicación será ejecutada como <code>cargo run &lt;input-path&gt; &lt;num-threads&gt; &lt;output-file-name&gt;</code></p>
<ul>
<li>El formato del archivo de salida debe ser</li>
</ul>
<pre><code>{
    "padron": &lt;número de padron del alumno&gt;,
    "top_killers": {
        "&lt;killer_name 1&gt;": {
            "deaths": &lt;cantidad total de muertes ejecutadas por el jugador&gt;,
            "weapons_percentage": {
                "&lt;weapon name 1&gt;": &lt;% de uso respecto del total de muertes ocasionadas por ese jugador&gt;,
                ...
            }
        },
        ...
        "&lt;killer_name N&gt;" : {
            ...
        }
    },
    "top_weapons": {
        "&lt;killed_by 1&gt;": {
          "deaths_percentage": &lt;% del total de muertes que produjo el arma&gt;,
          "average_distance": &lt;promedio de distancia entre el asesino y la víctima para el arma&gt;
        },
        ...
        "&lt;killed_by N&gt;": {

        },
    }
}
</code></pre>
<h2 id="requerimientos-no-funcionales-1"><a class="header" href="#requerimientos-no-funcionales-1">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>El archivo Cargo.toml se debe encontrar en la raíz del repositorio, para poder ejecutar correctamente los tests automatizados</li>
<li>Se deberán utilizar las herramientas de concurrencia correspondientes al modelo forkjoin</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados en este enunciado, en los ejemplos de la materia, o autorizados expresamente por los profesores. Para el procesamiento de JSON se puede utilizar el crate <code>serde_json</code>.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega-1"><a class="header" href="#entrega-1">Entrega</a></h2>
<p>La resolución del presente proyecto es individual.</p>
<p>La entrega del proyecto se realizará mediante Github Classroom. Cada estudiante tendrá un repositorio disponible para
hacer diferentes commits con el objetivo de resolver el problema propuesto. Se recomienda iniciar tempranamente y
hacer commits pequeños agreguen funcionalidad incrementalmente.
Se podrán hacer commit hasta el día de la entrega a las 19 hs Arg, luego el sistema automáticamente quitará el acceso
de escritura.</p>
<h2 id="evaluación-1"><a class="header" href="#evaluación-1">Evaluación</a></h2>
<h3 id="principios-teóricos-y-corrección-de-bugs-1"><a class="header" href="#principios-teóricos-y-corrección-de-bugs-1">Principios teóricos y corrección de bugs</a></h3>
<p>La evaluación se realizará sobre Github, pudiendo el profesor hacer comentarios en el repositorio y solicitar cambios
o mejoras cuando lo encuentre oportuno, especialmente debido al uso incorrecto de herramientas de concurrencia.</p>
<h3 id="casos-de-prueba-1"><a class="header" href="#casos-de-prueba-1">Casos de prueba</a></h3>
<p>Se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de
concurrencia, por ejemplo, la ausencia de deadlocks.</p>
<p>Además la aplicación deberá respetar los formatos de salida y valores esperados de los resultados, y deberá mostrar algún
incremento en performance cuando la ejecución de la misma se hace con varios hilos en un ambiente multiprocesador.</p>
<h3 id="organización-del-código-1"><a class="header" href="#organización-del-código-1">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust. Se prohibe el uso de bloques <code>unsafe</code>.</p>
<h3 id="tests-automatizados-1"><a class="header" href="#tests-automatizados-1">Tests automatizados</a></h3>
<p>La presencia de tests automatizados que prueben diferentes casos, en especial sobre el uso de las herramientas de concurrencia es un plus.</p>
<h3 id="presentación-en-término-1"><a class="header" href="#presentación-en-término-1">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influye negativamente en la nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-2"><a class="header" href="#trabajo-práctico-2">Trabajo Práctico</a></h1>
<h2 id="introducción-2"><a class="header" href="#introducción-2">Introducción</a></h2>
<p>ConcuRide es una nueva aplicación para conectar conductores y pasajeros. Gracias a su inovadora implementación distribuida, permitirá reducir los costos y apuntar a ser líder en el mercado.</p>
<p>Los pasajeros tendrán una app donde podrán elegir el destino, y los choferes una app donde recibirán y podrán aceptar o denegar viajes.</p>
<h2 id="objetivo-2"><a class="header" href="#objetivo-2">Objetivo</a></h2>
<p>Deberán implementar un conjunto de aplicaciones en Rust que modele el sistema.</p>
<h2 id="requerimientos-2"><a class="header" href="#requerimientos-2">Requerimientos</a></h2>
<ul>
<li>
<p>Una aplicación modelará la app para los pasajeros. Por simplificación, las coordenadas de origen y destino del viaje se modelarán con un par de enteros pequeños. Por ejemplo un viaje puede ser desde (3, 5) hacia (24,16). La app informará cuando un conductor acepte el viaje, y luego cuando esté terminado. Habrán varias instancias que se ejecutarán concurrentemente, una por cada pasajero.</p>
</li>
<li>
<p>Otra aplicación simulará a los conductores. Los mismos irán informando la ubicación actual del vehículo (simulada aleatoreamente o bien con un control, lo que simplifique los casos de prueba). El conductor recibirá ofertas de viajes
cercanos a su posición actual (por ejemplo con una distancia de 5 entre el origen y su posición). Un único conductor puede recibir la oferta del viaje por cada vez; y tiene un tiempo corto para aceptarla. La aceptación o rechazo se modelará con un random.
Al aceptar, el tiempo viaje se modelará con un sleep, luego del cual se terminará el viaje y el conductor quedará disponible para tomar otro.</p>
</li>
<li>
<p>Se debe considerar la autorización del pago al momento de solicitar el viaje, y el cobro efectivo al momento de llegar a destino. Modelar el gateway de pagos con una aplicación simple que loguea. Considerar que al momento de autorizar el pago, el gateway puede rechazar la tarjeta aleatoriamente con una probabilidad.</p>
</li>
<li>
<p>El sistema debe ser resiliente, soportando la caida de algunas instancias de las aplicaciones.</p>
</li>
<li>
<p>El sistema debe intentar minimizar la cantidad de mensajes que viajan por toda la red; por ejemplo enviando mensajes solo a los nodos que se encuentren cercanos por ubicación.</p>
</li>
</ul>
<h2 id="requerimientos-no-funcionales-2"><a class="header" href="#requerimientos-no-funcionales-2">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>Por lo menos alguna, si no todas las aplicaciones implementadas deben funcionar utilizando el <strong>modelo de actores</strong>.</li>
<li>Cada instancia de cada aplicación debe ejecutarse en un proceso independiente.</li>
<li>En el modelado de la solución se deberán utilizar una o mas de las herramientas de concurrencia distribuida mostradas en la cátedra. Por ejemplo exclusiones mutuas distribuidas, elección de líder, algorítmos de anillo, commits de dos fases, etc.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados en este enunciado, los utilizados en las clases, o los autorizados expresamente por los profesores.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entregas"><a class="header" href="#entregas">Entregas</a></h2>
<p>La resolución del presente proyecto es en grupos de tres integrantes.</p>
<p>Las entregas del proyecto se realizarán mediante Github Classroom. Cada grupo tendrá un repositorio disponible para hacer diferentes commits con el objetivo de resolver el problema propuesto.</p>
<h3 id="primera-entrega-diseño"><a class="header" href="#primera-entrega-diseño">Primera entrega: Diseño</a></h3>
<p>Deberán entregar un informe en formato Markdown en el <code>README.md</code> del repositorio que contenga una explicación del diseño y de las decisiones tomadas para la implementación de la solución, asi como diagramas de threads y procesos, y la comunicación entre los mismos; y diagramas de las entidades principales.</p>
<p>De cada entidad se debe describir:</p>
<ul>
<li>Finalidad general</li>
<li>Su estado interno, como uno o varios structs en pseudocodigo de Rust.</li>
<li>Mensajes que recibe, struct del payload de los mismos  y como reaccionará cuando los recibe.</li>
<li>Mensajes que envía, struct del payload de los mismos y hacia quienes son enviados.</li>
<li>Protolos de transporte (TCP/UDP) y de aplicación que utiliza para comunicarse.</li>
<li>Casos de interés (felices, caídas)</li>
</ul>
<p>Se recomienda fuertemente que las implementaciones de las ideas de diseño se encuentren realizadas mínimamente, para validar el mismo.</p>
<p><strong>Fecha máxima de Entrega: 13 de Noviembre de 2024</strong></p>
<p>Presentar como un pull-request del README.md.</p>
<p>El diseño será evaluado por la cátedra y de no presentarse a término el trabajo quedará automaticamente desaprobado.</p>
<p>La cátedra podrá solicitar correciones que deberán realizarse en el mismo diseño, y puntos de mejora
que deberán tenerse en cuenta durante la implementación.</p>
<p>Se podrán hacer commits hasta el día de la entrega a las 19 hs Arg, luego el sistema automáticamente quitará el acceso de escritura.</p>
<h3 id="segunda-entrega-código-final---3-de-diciembre-de-2024"><a class="header" href="#segunda-entrega-código-final---3-de-diciembre-de-2024">Segunda entrega: Código final - 3 de Diciembre de 2024</a></h3>
<ul>
<li>Deberá incluirse el código de la solución completa.</li>
<li>Deberá actualizarse el readme, con una sección dedicada a cambios que se hayan realizado desde la primera entrega. Además debe incluir cualquier explicación y/o set de comandos necesarios para la ejecución de los programas.</li>
</ul>
<h3 id="presentación-final-3-4-10-y-11-de-diciembre"><a class="header" href="#presentación-final-3-4-10-y-11-de-diciembre">Presentación final: 3, 4, 10 y 11 de Diciembre</a></h3>
<p>Cada grupo presentará presencialmente a un profesor de la cátedra su trabajo. La fecha y horario para cada grupo serán definidos oportunamente.</p>
<p>La presentación deberá incluir un resumen del diseño de la solución y la muestra en vivo de las aplicaciones funcionando, demostrando casos de interes.</p>
<p>Todos los integrantes del grupo deberán exponer algo. La evaluación es individual.</p>
<p>La cátedra podrá solicitar luego correcciones donde se encuentren errores severos, sobre todo en el uso de herramientas de concurrencia; o bien desviaciones respecto al diseño pactado inicialmente.</p>
<p>De tener correciones para realizar, las mismas deben realizarse y aprobarse con anterioridad a la presentación a examen final.</p>
<h2 id="evaluación-2"><a class="header" href="#evaluación-2">Evaluación</a></h2>
<h3 id="principios-teóricos-y-corrección-de-bugs-2"><a class="header" href="#principios-teóricos-y-corrección-de-bugs-2">Principios teóricos y corrección de bugs</a></h3>
<p>Los alumnos presentarán el diseño, código y comportamiento en vivo de su solución, con foco en el uso de las diferentes herramientas de concurrencia.</p>
<p>Deberán poder explicar desde los conceptos teóricos vistos en clase cómo se comportará potencialmente su solución ante problemas de concurrencia (por ejemplo ausencia de deadlocks).</p>
<p>En caso de que la solución no se comportara de forma esperada, deberán poder explicar las causas y sus posibles rectificaciones.</p>
<h3 id="casos-de-prueba-2"><a class="header" href="#casos-de-prueba-2">Casos de prueba</a></h3>
<p>Se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia y la resiliencia de las distintas entidades.</p>
<h3 id="informe"><a class="header" href="#informe">Informe</a></h3>
<p>El informe debe poder dar cuenta de todas las decisiones tomadas para implementar la solución, incluyendo diferentes diagramas y se debe poder utilizar como soporte para que el equipo presente su trabajo.</p>
<h3 id="organización-del-código-2"><a class="header" href="#organización-del-código-2">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust.
Se prohibe el uso de bloques <code>unsafe</code>.</p>
<h3 id="tests-automatizados-2"><a class="header" href="#tests-automatizados-2">Tests automatizados</a></h3>
<p>La entrega debe contar con tests automatizados que prueben diferentes casos. Se considerará en especial aquellos que pongan a prueba el uso de las herramientas de concurrencia.</p>
<h3 id="presentación-en-término-2"><a class="header" href="#presentación-en-término-2">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influirá negativamente en la nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1er-cuatrimestre-2024-1"><a class="header" href="#1er-cuatrimestre-2024-1">1er Cuatrimestre 2024</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-3"><a class="header" href="#trabajo-práctico-3">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong> 17 de Abril</p>
<h2 id="introducción-3"><a class="header" href="#introducción-3">Introducción</a></h2>
<p>Stack Exchange publica periódicamente el dump de todas las preguntas y respuestas realizadas en los sitios de su red.</p>
<p>Queremos aprovechar esto para realizar un análisis de los temas que se hablan en los sitios.
Para ello utilizaremos los tags que cada pregunta tiene asociada.</p>
<h2 id="objetivo-3"><a class="header" href="#objetivo-3">Objetivo</a></h2>
<p>Implementar una aplicación en Rust para procesamiento de información, aprovechando las ventajas del modelo Fork-Join, utilizando el dataset https://huggingface.co/datasets/flax-sentence-embeddings/stackexchange_title_body_jsonl</p>
<h2 id="requerimientos-3"><a class="header" href="#requerimientos-3">Requerimientos</a></h2>
<ul>
<li>La aplicación debe procesar todos los archivos <code>.jsonl</code> en el subdirectorio <code>data</code>. Puede utilizar el comando <code>download_data.sh</code> para descargar el dataset y descomprimirlo automáticamente.</li>
<li>Debe recibir un único parámetro entero por linea de comandos indicando la cantidad de worker threads con la cual procesar la información</li>
<li>Debe presentar un resultado final de procesamiento en JSON por consola con el siguiente formato</li>
</ul>
<pre><code>{
    "padron": &lt;número de padron del alumno&gt;,
    "sites": {
        "site1": {
            "questions": &lt;cantidad total de preguntas para ese sitio&gt;,
            "words": &lt;cantidad total de palabras para ese sitio&gt;,
            "tags": {
                "tag1": {
                    "questions": &lt;cantidad total de preguntas para ese tag para ese sitio&gt;,
                    "words": &lt;cantidad total palabras para ese tag para ese sitio&gt;,
                },
                ...
                "tagN": {

                },
            }
            "chatty_tags": [
                "tag1", "tag2", ... // los 10 tags con mayor relación words/questions para ese sitio
            ]
        },
        ...
        "siteN" : {
            ...
        }
    },
    "tags": {
        "tag1": {
            "questions": &lt;cantidad total de preguntas para ese tag para todos los sitios&gt;,
            "words": &lt;cantidad total palabras para ese tag para todos los sitios&gt;,
        },
        ...
        "tagN": {

        },
    },
    "totals": {
        "chatty_sites": [
            "site1", "site2", ... // los 10 sitios con mayor relación words/questions
        ],
        "chatty_tags": [
            "tag1", "tag2", ... // los 10 tags con mayor relación words/questions entre todos los sitios.
        ]
    }
}
</code></pre>
<h2 id="requerimientos-no-funcionales-3"><a class="header" href="#requerimientos-no-funcionales-3">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>El archivo Cargo.toml se debe encontrar en la raíz del repositorio, para poder ejecutar correctamente los tests automatizados</li>
<li>Se deberán utilizar las herramientas de concurrencia correspondientes al modelo forkjoin</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados en este enunciado, en los ejemplos de la materia, o autorizados expresamente por los profesores. Para el procesamiento de JSON se puede utilizar el crate <code>serde_json</code>.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega-2"><a class="header" href="#entrega-2">Entrega</a></h2>
<p>La resolución del presente proyecto es individual.</p>
<p>La entrega del proyecto se realizará mediante Github Classroom. Cada estudiante tendrá un repositorio disponible para
hacer diferentes commits con el objetivo de resolver el problema propuesto. Se recomienda iniciar tempranamente y
hacer commits pequeños agreguen funcionalidad incrementalmente.
Se podrán hacer commit hasta el día de la entrega a las 19 hs Arg, luego el sistema automáticamente quitará el acceso
de escritura.</p>
<h2 id="evaluación-3"><a class="header" href="#evaluación-3">Evaluación</a></h2>
<h3 id="principios-teóricos-y-corrección-de-bugs-3"><a class="header" href="#principios-teóricos-y-corrección-de-bugs-3">Principios teóricos y corrección de bugs</a></h3>
<p>La evaluación se realizará sobre Github, pudiendo el profesor hacer comentarios en el repositorio y solicitar cambios
o mejoras cuando lo encuentre oportuno, especialmente debido al uso incorrecto de herramientas de concurrencia.</p>
<h3 id="casos-de-prueba-3"><a class="header" href="#casos-de-prueba-3">Casos de prueba</a></h3>
<p>Se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia.</p>
<h3 id="organización-del-código-3"><a class="header" href="#organización-del-código-3">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust. Se prohibe el uso de bloques <code>unsafe</code>.</p>
<h3 id="tests-automatizados-3"><a class="header" href="#tests-automatizados-3">Tests automatizados</a></h3>
<p>La presencia de tests automatizados que prueben diferentes casos, en especial sobre el uso de las herramientas de concurrencia es un plus.</p>
<h3 id="presentación-en-término-3"><a class="header" href="#presentación-en-término-3">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influye negativamente en la nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-4"><a class="header" href="#trabajo-práctico-4">Trabajo Práctico</a></h1>
<h2 id="introducción-4"><a class="header" href="#introducción-4">Introducción</a></h2>
<p>Una importante cadena de heladerías desea abrir una sucursal completamente robotizada.
Los clientes harán su pedido sobre una interfáz gráfica eligiendo gustos y tamaño. Luego un conjunto de robots podrán resolver los pedidos de forma concurrente, tal como lo hacen los heladeros los días de calor. Así mismo, cada contenedor con un gusto de helado podrá ser utilizado solamente por un robot a la vez. Finalmente se le entregará su helado al cliente; y solamente se le cobrará en la tarjeta si efectivamente se pudo completar su pedido.</p>
<h2 id="objetivo-4"><a class="header" href="#objetivo-4">Objetivo</a></h2>
<p>Deberán implementar un conjunto de aplicaciones en Rust que modele el sistema de la heladería.</p>
<h2 id="requerimientos-4"><a class="header" href="#requerimientos-4">Requerimientos</a></h2>
<ul>
<li>Una aplicación modelará las interfaces con los clientes, las cuales generarán ordenes de pedido según un archivo de pedidos simulado. Deben soportar varios gustos y tamaños posibles de contenedor. Habrán varias instancias, tantas como pantallas disponibles en el local.</li>
<li>Otra aplicación simulará los robots, los cuales tomarán un pedido y deberán obtener los ingredientes necesarios para llenar el contenedor. El tamaño del contenedor definirá el tiempo para simular cada pedido. Nuevamente, serán varios los robots que despachen pedidos.</li>
<li>De alguna forma el sistema deberá modelar los contendores con gustos y el stock disponible en cada uno. Eventualmente algun gusto quedará sin stock, y un robot que necesite ese gusto deberá cancelar el pedido.</li>
<li>Se debe considerar la captura del pago al momento de realizar el pedido, y el cobro efectivo al momento de entrega, o bien su cancelación. Modelar el gateway de pagos con una aplicación simple que loguea. Considerar que al momento de capturar el pago, el gateway puede rechazar la tarjeta aleatoriamente con una probabilidad.</li>
<li>El sistema debe ser resiliente, soportando la caida de algunas instancias de las aplicaciones.</li>
</ul>
<h2 id="requerimientos-no-funcionales-4"><a class="header" href="#requerimientos-no-funcionales-4">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>Por lo menos alguna, si no todas las aplicaciones implementadas deben funcionar utilizando el <strong>modelo de actores</strong>.</li>
<li>En el modelado de la solución se deberán utilizar una o mas de las herramientas de concurrencia distribuida mostradas en la cátedra. Por ejemplo exclusiones mutuas distribuidas, elección de líder, algorítmos de anillo, commits de dos fases, etc.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados en este enunciado, los utilizados en las clases, o los autorizados expresamente por los profesores.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entregas-1"><a class="header" href="#entregas-1">Entregas</a></h2>
<p>La resolución del presente proyecto es en grupos de tres integrantes.</p>
<p>Las entregas del proyecto se realizarán mediante Github Classroom. Cada grupo tendrá un repositorio disponible para hacer diferentes commits con el objetivo de resolver el problema propuesto.</p>
<h3 id="primera-entrega-diseño-1"><a class="header" href="#primera-entrega-diseño-1">Primera entrega: Diseño</a></h3>
<p>Deberán entregar un informe en formato Markdown en el <code>README.md</code> del repositorio que contenga una explicación del diseño y de las decisiones tomadas para la implementación de la solución, asi como diagramas de threads y procesos, y la comunicación entre los mismos; y diagramas de las entidades principales.</p>
<p>Se recomienda fuertemente que las implementaciones de las ideas de diseño se encuentren realizadas mínimamente, para validar el mismo.</p>
<p><strong>Fecha máxima de Entrega: 12 de Junio de 2024</strong></p>
<p>El diseño será evaluado por la cátedra y de no presentarse a término el trabajo quedará automaticamente desaprobado.</p>
<p>La cátedra podrá solicitar correciones que deberán realizarse en el mismo diseño, y puntos de mejora
que deberán tenerse en cuenta durante la implementación.</p>
<p>Se podrán hacer commits hasta el día de la entrega a las 19 hs Arg, luego el sistema automáticamente quitará el acceso de escritura.</p>
<h3 id="segunda-entrega-26-de-junio-de-2024"><a class="header" href="#segunda-entrega-26-de-junio-de-2024">Segunda entrega:** 26 de Junio de 2024</a></h3>
<ul>
<li>Deberá incluirse el código de la solución completa.</li>
<li>Deberá actualizarse el readme, con una sección dedicada a cambios que se hayan realizado desde la primera entrega. Además debe incluir cualquier explicación y/o set de comandos necesarios para la ejecución de los programas.</li>
<li>Debera incluir un enlace a un video de no más de 7 minutos donde cada integrante presente su participación principal en el proyecto, explicando las partes más relevantes del código que trabajó. El video debe mostrar además la solución funcionando en diferentes casos de interés.</li>
</ul>
<p>La cátedra podrá solicitar luego correcciones donde se encuentren errores severos, sobre todo en el uso de herramientas de concurrencia; o bien desviaciones respecto al diseño pactado inicialmente.</p>
<p>De tener correciones para realizar, las mismas deben realizarse y aprobarse con anterioridad a la presentación a examen final.</p>
<h3 id="entrega-final"><a class="header" href="#entrega-final">Entrega final</a></h3>
<p>Durante el examen final, los alumnos deberán poder responder preguntas sobre su diseño e implementación, y su participación personal en el trabajo; además de las preguntas y situaciones problemáticas propias de los contenidos presentados por la cátedra durante toda la materia.</p>
<h2 id="evaluación-4"><a class="header" href="#evaluación-4">Evaluación</a></h2>
<h3 id="principios-teóricos-y-corrección-de-bugs-4"><a class="header" href="#principios-teóricos-y-corrección-de-bugs-4">Principios teóricos y corrección de bugs</a></h3>
<p>Los alumnos presentarán el código de su solución primero en video, y luego personalmente, con foco en el uso de las diferentes herramientas de concurrencia.
Deberán poder explicar desde los conceptos teóricos vistos en clase cómo se comportará potencialmente su solución ante problemas de concurrencia (por ejemplo ausencia de deadlocks).</p>
<p>En caso de que la solución no se comportara de forma esperada, deberán poder explicar las causas y sus posibles rectificaciones.</p>
<h3 id="casos-de-prueba-4"><a class="header" href="#casos-de-prueba-4">Casos de prueba</a></h3>
<p>Se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia y la resiliencia de las distintas entidades.</p>
<h3 id="informe-1"><a class="header" href="#informe-1">Informe</a></h3>
<p>El informe debe poder dar cuenta de todas las decisiones tomadas para implementar la solución, incluyendo diferentes diagramas y se debe poder utilizar como soporte para que el equipo presente su trabajo.</p>
<h3 id="organización-del-código-4"><a class="header" href="#organización-del-código-4">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust.
Se prohibe el uso de bloques <code>unsafe</code>.</p>
<h3 id="tests-automatizados-4"><a class="header" href="#tests-automatizados-4">Tests automatizados</a></h3>
<p>La entrega debe contar con tests automatizados que prueben diferentes casos. Se considerará en especial aquellos que pongan a prueba el uso de las herramientas de concurrencia.</p>
<h3 id="presentación-en-término-4"><a class="header" href="#presentación-en-término-4">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influirá negativamente en la nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2do-cuatrimestre-2023"><a class="header" href="#2do-cuatrimestre-2023">2do Cuatrimestre 2023</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-5"><a class="header" href="#trabajo-práctico-5">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong> 21 de Noviembre de 2023</p>
<h2 id="introducción-5"><a class="header" href="#introducción-5">Introducción</a></h2>
<p>Nos encontramos desarrollando un software para una cadena de tiendas distribuida por todo el país. La misma tiene un sitio de e-commerce además de locales físicos.</p>
<p>En este caso estamos trabajando el módulo de manejo de stocks. Se pueden registrar compras en cada tienda física, así como también desde el e-commerce. El sitio de e-commerce reserva stock de producto de la tienda más cercana posible a la dirección de envío de la compra idealmente (modelar de forma aleatoria), pero puede potencialmente tomar el stock de cualquier local de ser necesario.</p>
<h2 id="objetivo-5"><a class="header" href="#objetivo-5">Objetivo</a></h2>
<p>Deberán implementar un conjunto de aplicaciones en Rust que modele el sistema de stocks.</p>
<h2 id="requerimientos-5"><a class="header" href="#requerimientos-5">Requerimientos</a></h2>
<ul>
<li>Una aplicación modelará el sitio de e-commerce, la cual generará ordenes según un archivo de pedidos simulado.</li>
<li>Otra aplicación simulará las terminales de cobro en los locales, habiendo N instancias de esta aplicación (una por cada local). Cada terminal simulará los pedidos también desde un archivo de ordenes.</li>
<li>En el caso de compras por e-commerce, el stock del producto se bloquea, pero no se descuenta hasta que el producto es efectivamente entregado.</li>
<li>La entrega puede no realizarse a tiempo, con lo cual la compra se cancela y el stock se libera (modelar con un random).</li>
<li>Debido a que las tiendas se encuentran por todo el pais, en algunos casos con muy mala conexión, los nodos de cada tienda pueden entrar y salir de la red espontáneamente.</li>
<li>Mientras se encuentran fuera de red, los servidores pueden seguir actualizando stocks con ventas locales; no así con las de e-commerce.</li>
<li>Al volver a conectarse, deben sincronizar los stocks</li>
</ul>
<h2 id="requerimientos-no-funcionales-5"><a class="header" href="#requerimientos-no-funcionales-5">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>Alguna de las aplicaciones implementadas debe funcionar utilizando el <strong>modelo de actores</strong>.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados en este enunciado, o autorizados expresamente por los profesores.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega-3"><a class="header" href="#entrega-3">Entrega</a></h2>
<p>La resolución del presente proyecto es en grupos de tres integrantes.</p>
<p>La entrega del proyecto se realizará mediante Github Classroom. Cada grupo tendrá un repositorio disponible para hacer diferentes commits con el objetivo de resolver el problema propuesto. Se recomienda iniciar tempranamente y trabajar siguiendo un formato de commits pequeños que agreguen funcionalidad incrementalmente.
Se podrán hacer commits hasta el día de la entrega a las 19 hs Arg, luego el sistema automáticamente quitará el acceso de escritura.</p>
<p>Asi mismo el proyecto debe incluir un informe en formato Markdown en el <code>README.md</code> del repositorio que contenga una explicación del diseño y de las decisiones tomadas para la implementación de la solución, asi como diagramas de threads y procesos, y la comunicación entre los mismos; y diagramas de las entidades principales.
En el mismo archivo deberá proveerse cualquier explicación y/o set de comandos necesarios para la ejecución de los programas.</p>
<h2 id="evaluación-5"><a class="header" href="#evaluación-5">Evaluación</a></h2>
<h3 id="principios-teóricos-y-corrección-de-bugs-5"><a class="header" href="#principios-teóricos-y-corrección-de-bugs-5">Principios teóricos y corrección de bugs</a></h3>
<p>Los alumnos presentarán el código de su solución presencialmente, con foco en el uso de las diferentes herramientas de concurrencia.
Deberán poder explicar desde los conceptos teóricos vistos en clase cómo se comportará potencialmente su solución ante  problemas de concurrencia (por ejemplo ausencia de deadlocks).</p>
<p>En caso de que la solución no se comportara de forma esperada, deberán poder explicar las causas y sus posibles rectificaciones.</p>
<h3 id="casos-de-prueba-5"><a class="header" href="#casos-de-prueba-5">Casos de prueba</a></h3>
<p>Se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia.</p>
<h3 id="informe-2"><a class="header" href="#informe-2">Informe</a></h3>
<p>El informe debe poder dar cuenta de todas las decisiones tomadas para implementar la solución, incluyendo diferentes diagramas y se debe poder utilizar como soporte para que el equipo presente su trabajo.</p>
<h3 id="organización-del-código-5"><a class="header" href="#organización-del-código-5">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust.
Se prohibe el uso de bloques <code>unsafe</code>.</p>
<h3 id="tests-automatizados-5"><a class="header" href="#tests-automatizados-5">Tests automatizados</a></h3>
<p>La entrega debe contar con tests automatizados que prueben diferentes casos. Se considerará en especial aquellos que pongan a prueba el uso de las herramientas de concurrencia.</p>
<h3 id="presentación-en-término-5"><a class="header" href="#presentación-en-término-5">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influirá negativamente en la nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1er-cuatrimestre-2023"><a class="header" href="#1er-cuatrimestre-2023">1er Cuatrimestre 2023</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-6"><a class="header" href="#trabajo-práctico-6">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong> 3 de mayo de 2023</p>
<h2 id="introducción-6"><a class="header" href="#introducción-6">Introducción</a></h2>
<p><em>CoffeeGPT</em> es una nueva cadena de cafeterías que pretende competir con tantas otras con un novedoso
modelo de negocio: los clientes son servidos por robots que preparan sus órdenes de forma totalmente automática.</p>
<p>De entre los multiples desarrollos necesarios para implementar este proyecto, nos han contratado para realizar el software
que controlará las cafeteras espresso.</p>
<h2 id="objetivo-6"><a class="header" href="#objetivo-6">Objetivo</a></h2>
<p>Deberán implementar una aplicación en Rust que modele el sistema de control y reporte de la cafetera inteligente.</p>
<p>Cada pedido de bebida a preparar se leerá como una línea de un archivo y los movimientos de los distintos actuadores se simularán con un sleep.</p>
<h2 id="requerimientos-6"><a class="header" href="#requerimientos-6">Requerimientos</a></h2>
<ul>
<li>
<p>Cada cafetera dispone de N dispensadores independientes que pueden aplicar agua caliente, café molido, cacao o espuma de leche.</p>
</li>
<li>
<p>Además la cafetera esta compuesta por:</p>
<ul>
<li>Un contenedor de granos para moler de capacidad G</li>
<li>Un contenedor para granos molidos de capacidad M</li>
<li>Un contenedor de leche fría de capacidad L</li>
<li>Un contenedor de espuma de leche de capacidad E</li>
<li>Un contenedor de cacao de capacidad C</li>
<li>Un contenedor de agua, donde esta se toma de la red y luego calienta, de capacidad A.</li>
</ul>
</li>
<li>
<p>Cada pedido se representa con una línea en un archivo de texto que indicará las cantidades de café molido, agua caliente, cacao y/o espuma de leche necesarias para preparar la bebida solicitada.</p>
</li>
<li>
<p>Las cantidades se "aplicarán" como tiempos de sleep además de descontar del correspondiente contenedor.</p>
</li>
<li>
<p>Un solo dispenser a por vez puede tomar ingredientes de cada contenedor, es decir, no es posible por ejemplo que dos disponsers tomen café concurrentemente.</p>
</li>
<li>
<p>Cuando el contenedor de cafe molido se agota, el molinillo automático toma una cantidad de granos y los convierte en café molido. Este proceso toma tiempo y no se puede obtener café durante el mismo.</p>
</li>
<li>
<p>Análogamente sucede lo mismo con la leche y la espuma, y con el agua caliente.</p>
</li>
<li>
<p>El sistema debe minimizar los tiempos de espera de los clientes, maximizando la producción concurrente.</p>
</li>
<li>
<p>El sistema debe alertar por consola cuando los contenedores de granos, leche y cacao se encuentran por debajo de X% de capacidad.</p>
</li>
<li>
<p>El sistema debe presentar periódicamente estadísticas con los niveles de todos los contenedores, cantidad total de bebidas preparadas y cantidad total de ingredientes consumidos.</p>
</li>
</ul>
<h2 id="requerimientos-no-funcionales-6"><a class="header" href="#requerimientos-no-funcionales-6">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>Se deberán utilizar las herramientas de concurrencia correspondientes al modelo de estado mutable compartido.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados en este enunciado, o autorizados expresamente por los profesores.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega-4"><a class="header" href="#entrega-4">Entrega</a></h2>
<p>La resolución del presente proyecto es individual.</p>
<p>La entrega del proyecto se realizará mediante Github Classroom. Cada estudiante tendrá un repositorio disponible para
ir haciendo diferentes commits con el objetivo de resolver el problema propuesto. Se recomienda iniciar tempranamente y
hacer commits pequeños agreguen funcionalidad incrementalmente.
Se podrán hacer commit hasta el día de la entrega a las 19 hs Arg, luego el sistema automáticamente quitará el acceso
de escritura.</p>
<p>Asi mismo el proyecto debe incluir un pequeño informe en formato Markdown en el README.md del repositorio que contenga una
explicación del diseño y de las decisiones tomadas para la implementación de la solución.</p>
<h2 id="evaluación-6"><a class="header" href="#evaluación-6">Evaluación</a></h2>
<h3 id="principios-teóricos-y-corrección-de-bugs-6"><a class="header" href="#principios-teóricos-y-corrección-de-bugs-6">Principios teóricos y corrección de bugs</a></h3>
<p>La evaluación se realizará sobre Github, pudiendo el profesor hacer comentarios en el repositorio y solicitar cambios
o mejoras cuando lo encuentre oportuno, especialmente debido al uso incorrecto de herramientas de concurrencia (por ejemplo presencia de posibles deadlocks).</p>
<h3 id="casos-de-prueba-6"><a class="header" href="#casos-de-prueba-6">Casos de prueba</a></h3>
<p>Se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia.</p>
<h3 id="informe-3"><a class="header" href="#informe-3">Informe</a></h3>
<p>El informe debe estar estructurado profesionalmente y debe poder dar cuenta de las decisiones tomadas para implementar la solución.</p>
<h3 id="organización-del-código-6"><a class="header" href="#organización-del-código-6">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust. Se prohibe el uso de bloques <code>unsafe</code>.</p>
<h3 id="tests-automatizados-6"><a class="header" href="#tests-automatizados-6">Tests automatizados</a></h3>
<p>La presencia de tests automatizados que prueben diferentes casos, en especial sobre el uso de las herramientas de concurrencia es un plus.</p>
<h3 id="presentación-en-término-6"><a class="header" href="#presentación-en-término-6">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influye negativamente en la nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-7"><a class="header" href="#trabajo-práctico-7">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong> 13 de junio de 2023</p>
<h2 id="introducción-7"><a class="header" href="#introducción-7">Introducción</a></h2>
<p>Continuamos con los desarrollos para <em>CoffeeGPT</em>.</p>
<p>Coffeewards, es un sistema de puntos para fidelización de los clientes.
Por cada compra que realizan los clientes, suman puntos que luego pueden canjear por cafes gratuitos.</p>
<h2 id="objetivo-7"><a class="header" href="#objetivo-7">Objetivo</a></h2>
<p>Deberán implementar un conjunto de aplicaciones en Rust que modele el sistema de puntos.</p>
<h2 id="requerimientos-7"><a class="header" href="#requerimientos-7">Requerimientos</a></h2>
<ul>
<li>Una aplicación modelará la cafetera robot, la cual agregará o retirará puntos de las tarjetas, según un archivo de pedidos simulado. Deberán correr varias instancias en simultáneo, simulando los multiples locales de la empresa y cafeteras de cada local.</li>
<li>Cada cliente suma y comparte sus puntos con su grupo familiar; por lo tanto una misma cuenta de puntos se puede estar
utilizando en varios locales/cafeteras en simultáneo. Se debe mantener el saldo de cada cuenta consistente.</li>
<li>En el caso de pagar un café con puntos, los mismos se bloquean, pero no se descuentan hasta que el café fue efectivamente entregado al cliente.</li>
<li>La cafetera puede fallar en preparar la bebida con cierta probabilidad, debiendo devolver los puntos.</li>
<li>El sistema es distribuido, cada local de CoffeeGPT tiene un servidor que mantiene los estados de cuenta. Las cafeteras se conectan con su servidor local.</li>
<li>Debido a que se encuentran por todo el pais, en algunos casos con muy mala conexión, los servidores pueden entrar y salir de la red espontáneamente.
<ul>
<li>Mientras se encuentran fuera de red, los servidores pueden seguir acumulando puntos en las cuentas. No así retirar.</li>
<li>Al volver a conectarse, deben sincronizar los estados de cuenta</li>
</ul>
</li>
</ul>
<h2 id="requerimientos-no-funcionales-7"><a class="header" href="#requerimientos-no-funcionales-7">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>Alguna de las aplicaciones implementadas debe funcionar utilizando el <strong>modelo de actores</strong>.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados en este enunciado, o autorizados expresamente por los profesores.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega-5"><a class="header" href="#entrega-5">Entrega</a></h2>
<p>La resolución del presente proyecto es en grupos de tres integrantes.</p>
<p>La entrega del proyecto se realizará mediante Github Classroom. Cada grupo tendrá un repositorio disponible para
hacer diferentes commits con el objetivo de resolver el problema propuesto. Se recomienda iniciar tempranamente y
hacer commits pequeños agreguen funcionalidad incrementalmente.
Se podrán hacer commits hasta el día de la entrega a las 19 hs Arg, luego el sistema automáticamente quitará el acceso
de escritura.</p>
<p>Asi mismo el proyecto debe incluir un informe en formato Markdown en el README.md del repositorio que contenga una
explicación del diseño y de las decisiones tomadas para la implementación de la solución, asi como diagramas de threads y procesos,
y la comunicación entre los mismos; y diagramas de las entidades principales.</p>
<h2 id="evaluación-7"><a class="header" href="#evaluación-7">Evaluación</a></h2>
<h3 id="principios-teóricos-y-corrección-de-bugs-7"><a class="header" href="#principios-teóricos-y-corrección-de-bugs-7">Principios teóricos y corrección de bugs</a></h3>
<p>Los alumnos presentarán el código de su solución presencialmente, con foco en el uso de las diferentes herramientas de concurrencia.
Deberán poder explicar desde los conceptos teóricos vistos en clase cómo se comportará potencialmente su solución ante
problemas de concurrencia (por ejemplo ausencia de deadlocks).</p>
<p>En caso de que la solución no se comportara de forma esperada, deberán poder explicar las causas y sus posibles rectificaciones.</p>
<h3 id="casos-de-prueba-7"><a class="header" href="#casos-de-prueba-7">Casos de prueba</a></h3>
<p>Se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia.</p>
<h3 id="informe-4"><a class="header" href="#informe-4">Informe</a></h3>
<p>El informe debe estar estructurado profesionalmente y debe poder dar cuenta de las decisiones tomadas para implementar la solución.</p>
<h3 id="organización-del-código-7"><a class="header" href="#organización-del-código-7">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust.
Se prohibe el uso de bloques <code>unsafe</code>.</p>
<h3 id="tests-automatizados-7"><a class="header" href="#tests-automatizados-7">Tests automatizados</a></h3>
<p>La presencia de tests automatizados que prueben diferentes casos, en especial sobre el uso de las herramientas de concurrencia es un plus.</p>
<h3 id="presentación-en-término-7"><a class="header" href="#presentación-en-término-7">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación
con el profesor influye negativamente en la nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2do-cuatrimestre-2022"><a class="header" href="#2do-cuatrimestre-2022">2do Cuatrimestre 2022</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-8"><a class="header" href="#trabajo-práctico-8">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong> 12 de octubre de 2022</p>
<h2 id="introducción-8"><a class="header" href="#introducción-8">Introducción</a></h2>
<p><em>Internet of Coffee</em> es una nueva cadena de cafeterías que pretende competir con tantas otras con un novedoso
modelo de negocio: los clientes son servidos por robots que preparan sus órdenes de forma totalmente automática.</p>
<p>De entre los multiples desarrollos necesarios para implementar este proyecto, nos han contratado para realizar el software
que controlará las cafeteras espresso.</p>
<h2 id="objetivo-8"><a class="header" href="#objetivo-8">Objetivo</a></h2>
<p>Deberán implementar una aplicación en Rust que modele el sistema de control y reporte de la cafetera inteligente.</p>
<p>Cada pedido de bebida a preparar se leerá como una línea de un archivo y los movimientos de los distintos actuadores se simularán con un sleep.</p>
<h2 id="requerimientos-8"><a class="header" href="#requerimientos-8">Requerimientos</a></h2>
<ul>
<li>
<p>Cada cafetera dispone de N dispensadores independientes que pueden aplicar agua caliente, café o espuma de leche.</p>
</li>
<li>
<p>Además la cafetera esta compuesta por:</p>
<ul>
<li>Un contenedor de granos para moler de capacidad G</li>
<li>Un contenedor para granos molidos de capacidad C</li>
<li>Un contenedor de leche fría de capacidad L</li>
<li>Un contenedor de espuma de leche de capacidad E</li>
<li>Por simplificación el agua es ilimitada, ya que se toma de la red.</li>
</ul>
</li>
<li>
<p>Cada pedido se representa con una línea en un archivo de texto. Por simplificación cada pedido "viene" con su
correspondiente vaso el cual se posiciona de forma externa a nuestro sistema directamente en el dispensador correcto.</p>
</li>
<li>
<p>Cada pedido indicará las cantidades de cafe molido, agua caliente y/o espuma de leche necesarias.</p>
</li>
<li>
<p>Las cantidades se "aplicarán" como tiempos de sleep además de descontar del correspondiente contenedor.</p>
</li>
<li>
<p>Un solo dispenser a la vez puede tomar café molido o espuma de leche. El agua es libre.</p>
</li>
<li>
<p>Cuando el contenedor de cafe molido se agota, el molinillo automático toma una cantidad de granos y los convierte en café molido. Este proceso toma tiempo y no se puede obtener café durante el mismo.</p>
</li>
<li>
<p>Análogamente sucede lo mismo con la leche y la espuma.</p>
</li>
<li>
<p>El sistema debe minimizar los tiempos de espera de los clientes, maximizando la producción concurrente.</p>
</li>
<li>
<p>El sistema debe alertar por consola cuando los contenedores de granos y leche se encuentran por debajo de X% de capacidad.</p>
</li>
<li>
<p>El sistema debe presentar periódicamente estadísticas con los niveles de todos los contenedores, cantidad total de bebidas preparadas y cantidad total de ingredientes consumidos.</p>
</li>
</ul>
<h2 id="requerimientos-no-funcionales-8"><a class="header" href="#requerimientos-no-funcionales-8">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>Se deberán utilizar las herramientas de concurrencia correspondientes al modelo de estado mutable compartido.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados en este enunciado, o autorizados expresamente por los profesores.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega-6"><a class="header" href="#entrega-6">Entrega</a></h2>
<p>La resolución del presente proyecto es individual.</p>
<p>La entrega del proyecto se realizará mediante Github Classroom. Cada estudiante tendrá un repositorio disponible para
ir haciendo diferentes commits con el objetivo de resolver el problema propuesto. Se recomienda iniciar tempranamente y
hacer commits pequeños agreguen funcionalidad incrementalmente.
Se podrán hacer commit hasta el día de la entrega a las 19 hs Arg, luego el sistema automáticamente quitará el acceso
de escritura.</p>
<p>Asi mismo el proyecto debe incluir un pequeño informe en formato Markdown en el README.md del repositorio que contenga una
explicación del diseño y de las decisiones tomadas para la implementación de la solución.</p>
<h2 id="evaluación-8"><a class="header" href="#evaluación-8">Evaluación</a></h2>
<h3 id="principios-teóricos-y-corrección-de-bugs-8"><a class="header" href="#principios-teóricos-y-corrección-de-bugs-8">Principios teóricos y corrección de bugs</a></h3>
<p>La evaluación se realizará sobre Github, pudiendo el profesor hacer comentarios en el repositorio y solicitar cambios
o mejoras cuando lo encuentre oportuno, especialmente debido al uso incorrecto de herramientas de concurrencia (por ejemplo presencia de posibles deadlocks).</p>
<h3 id="casos-de-prueba-8"><a class="header" href="#casos-de-prueba-8">Casos de prueba</a></h3>
<p>Se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia.</p>
<h3 id="informe-5"><a class="header" href="#informe-5">Informe</a></h3>
<p>El informe debe estar estructurado profesionalmente y debe poder dar cuenta de las decisiones tomadas para implementar la solución.</p>
<h3 id="organización-del-código-8"><a class="header" href="#organización-del-código-8">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust. Se prohibe el uso de bloques <code>unsafe</code>.</p>
<h3 id="tests-automatizados-8"><a class="header" href="#tests-automatizados-8">Tests automatizados</a></h3>
<p>La presencia de tests automatizados que prueben diferentes casos, en especial sobre el uso de las herramientas de concurrencia es un plus.</p>
<h3 id="presentación-en-término-8"><a class="header" href="#presentación-en-término-8">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influye negativamente en la nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-9"><a class="header" href="#trabajo-práctico-9">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong> 22 de noviembre de 2022</p>
<h2 id="introducción-9"><a class="header" href="#introducción-9">Introducción</a></h2>
<p>Continuamos con los desarrollos para <em>Internet of Coffee</em>.</p>
<p>Coffeewards, es un sistema de puntos para fidelización de los clientes.
Por cada compra que realizan los clientes, suman puntos que luego pueden canjear por cafes gratuitos.</p>
<h2 id="objetivo-9"><a class="header" href="#objetivo-9">Objetivo</a></h2>
<p>Deberán implementar un conjunto de aplicaciones en Rust que modele el sistema de puntos.</p>
<h2 id="requerimientos-9"><a class="header" href="#requerimientos-9">Requerimientos</a></h2>
<ul>
<li>Una aplicación modelará la cafetera robot, la cual agregará o retirará puntos de las tarjetas, según un archivo de pedidos simulado. Deberán correr varias instancias en simultáneo, simulando los multiples locales de la empresa y cafeteras de cada local.</li>
<li>Cada cliente suma y comparte sus puntos con su grupo familiar; por lo tanto una misma tarjeta de puntos se puede estar
utilizando en varios locales/cafeteras en simultáneo. Se debe mantener el saldo de cada cuenta consistente.</li>
<li>En el caso de pagar un café con puntos, los mismos se bloquean, pero no se descuentan hasta que el café fue efectivamente entregado al cliente.</li>
<li>La cafetera puede fallar en preparar la bebida con cierta probabilidad, debiendo devolver los puntos.</li>
<li>El sistema es distribuido, cada local de Internet of Coffee tiene un servidor que mantiene los estados de cuenta. Las cafeteras se conectan con su servidor local.</li>
<li>Debido a que se encuentran por todo el pais, en algunos casos con muy mala conexión, los servidores pueden entrar y salir de la red espontáneamente.
<ul>
<li>Mientras se encuentran fuera de red, los servidores pueden seguir acumulando puntos en las cuentas. No así retirar.</li>
<li>Al volver a conectarse, deben sincronizar los estados de cuenta</li>
</ul>
</li>
</ul>
<h2 id="requerimientos-no-funcionales-9"><a class="header" href="#requerimientos-no-funcionales-9">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>Alguna de las aplicaciones implementadas debe funcionar utilizando el modelo de actores.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados en este enunciado, o autorizados expresamente por los profesores.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega-7"><a class="header" href="#entrega-7">Entrega</a></h2>
<p>La resolución del presente proyecto es en grupos de tres integrantes.</p>
<p>La entrega del proyecto se realizará mediante Github Classroom. Cada grupo tendrá un repositorio disponible para
hacer diferentes commits con el objetivo de resolver el problema propuesto. Se recomienda iniciar tempranamente y
hacer commits pequeños agreguen funcionalidad incrementalmente.
Se podrán hacer commits hasta el día de la entrega a las 19 hs Arg, luego el sistema automáticamente quitará el acceso
de escritura.</p>
<p>Asi mismo el proyecto debe incluir un informe en formato Markdown en el README.md del repositorio que contenga una
explicación del diseño y de las decisiones tomadas para la implementación de la solución, asi como diagramas de threads y procesos,
y la comunicación entre los mismos; y diagramas de las entidades principales.</p>
<h2 id="evaluación-9"><a class="header" href="#evaluación-9">Evaluación</a></h2>
<h3 id="principios-teóricos-y-corrección-de-bugs-9"><a class="header" href="#principios-teóricos-y-corrección-de-bugs-9">Principios teóricos y corrección de bugs</a></h3>
<p>Los alumnos presentarán el código de su solución presencialmente, con foco en el uso de las diferentes herramientas de concurrencia. Deberán poder explicar desde los conceptos teóricos vistos en clase cómo se comportará potencialmente su solución ante problemas de concurrencia (por ejemplo ausencia de deadlocks).</p>
<p>En caso de que la solución no se comportara de forma esperada, deberán poder explicar las causas y sus posibles rectificaciones.</p>
<h3 id="casos-de-prueba-9"><a class="header" href="#casos-de-prueba-9">Casos de prueba</a></h3>
<p>Se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia.</p>
<h3 id="informe-6"><a class="header" href="#informe-6">Informe</a></h3>
<p>El informe debe estar estructurado profesionalmente y debe poder dar cuenta de las decisiones tomadas para implementar la solución.</p>
<h3 id="organización-del-código-9"><a class="header" href="#organización-del-código-9">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust. Se prohibe el uso de bloques <code>unsafe</code>.</p>
<h3 id="tests-automatizados-9"><a class="header" href="#tests-automatizados-9">Tests automatizados</a></h3>
<p>La presencia de tests automatizados que prueben diferentes casos, en especial sobre el uso de las herramientas de concurrencia es un plus.</p>
<h3 id="presentación-en-término-9"><a class="header" href="#presentación-en-término-9">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influye negativamente en la nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1er-cuatrimestre-2022"><a class="header" href="#1er-cuatrimestre-2022">1er Cuatrimestre 2022</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-10"><a class="header" href="#trabajo-práctico-10">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong> 28 de junio de 2022</p>
<h2 id="introducción-10"><a class="header" href="#introducción-10">Introducción</a></h2>
<p><em>AlGlobo.com</em> es un nuevo sitio de venta de pasajes online. Gracias al fin de la pandemia ha empezado a crecer fuertemente y necesitan escalar su sistema de procesamiento de pagos.</p>
<p>Para ello desean reemplazar una implementación monolítica actual con un microservicio en Rust que se encarge especificamente de este proceso.</p>
<h2 id="objetivo-10"><a class="header" href="#objetivo-10">Objetivo</a></h2>
<p>Deberán implementar un conjunto de aplicaciones en Rust que modele el sistema de procesamiento de pagos de AlGlobo.com.</p>
<p>Se debe implementar un proceso para cada una de las entidades intervinientes y estas se comunicarán entre sí por sockets.</p>
<p>Se debe poder simular la salida de servicio de cualquiera de los procesos y réplicas de forma aleatoria o voluntaria, mostrando que el sistema en su conjunto sigue funcionando.</p>
<h2 id="requerimientos-10"><a class="header" href="#requerimientos-10">Requerimientos</a></h2>
<p>El proceso de pagos se compone de la siguiente manera:</p>
<ul>
<li>Intervienen 4 entidades: AlGlobo.com, el banco, la aerolínea y el hotel.</li>
<li>Existe una cola de pagos a procesar que se lee desde un archivo.</li>
<li>AlGlobo.com debe coordinar el pago informando el monto a cobrar a cada entidad de forma concurrente.</li>
<li>Cada entidad puede aleatoriamente procesar correctamente el cobro o no.</li>
<li>Si alguna falla, se debe mantener la transaccionalidad y por lo tanto revertir o cancelar apropiadamente.</li>
<li>Las fallas se guardan en un archivo de fallas para su posterior procesamiento manual. Debe implementarse una utilidad que permita reintentar manualmente cada pedido fallado.</li>
<li>El sistema de AlGlobo.com es de misión crítica y por lo tanto debe mantener varias réplicas en línea listas para continuar el proceso, aunque solo una de ellas se encuentra activa al mismo tiempo. Para ello utiliza un algoritmo de elección de líder y mantiene sincronizado entre las réplicas la información del la transacción actual.</li>
<li>La aplicación de AlGlobo.com esta basada internamente en el modelo de Actores, utilizando el framework Actix.</li>
<li>Todas las aplicaciones deben escribir un archivo de log con las operaciones que se realizan y sus resultados.</li>
<li>El sistema mantendrá estadísticas operacionales. Para ello debe calcular el tiempo medio que toma un pago en procesarse desde que ingresa el pedido hasta que es finalmente procesado por todas las entidades.</li>
</ul>
<h2 id="requerimientos-no-funcionales-10"><a class="header" href="#requerimientos-no-funcionales-10">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega-8"><a class="header" href="#entrega-8">Entrega</a></h2>
<p>La resolución del presente proyecto es en grupos de tres integrantes.</p>
<p>La entrega del proyecto comprende lo siguiente:</p>
<ul>
<li>Informe, se deberá presentar en forma digital (PDF) enviado por correo electrónico a la dirección: pdeymon@fi.uba.ar</li>
<li>El código fuente de la aplicación, que se entregará únicamente por e-mail. El código fuente debe estar estructurado en un proyecto de cargo, y se debe omitir el directorio target/ en la entrega. El informe a entregar debe contener los siguientes items:
<ul>
<li>Una explicación del diseño y de las decisiones tomadas para la implementación de la solución.</li>
<li>Detalle de resolución de la lista de tareas anterior.</li>
<li>Diagrama que refleje los threads, el flujo de comunicación entre ellos y los datos que intercambian.</li>
<li>Diagramas de entidades realizados (structs y demás).</li>
</ul>
</li>
</ul>
<h2 id="criterios-de-evaluación"><a class="header" href="#criterios-de-evaluación">Criterios de evaluación</a></h2>
<h3 id="presentación-principios-teóricos-y-defensa-de-bugs-potenciales"><a class="header" href="#presentación-principios-teóricos-y-defensa-de-bugs-potenciales">Presentación, principios teóricos y defensa de bugs potenciales</a></h3>
<p>Los alumnos presentarán el código de su solución en vivo en una reunión sincrónica, con foco en el uso de las diferentes herramientas de concurrencia. Deberán poder explicar desde los conceptos teóricos vistos en clase cómo se comportará potencialmente su solución ante problemas de concurrencia (por ejemplo ausencia de deadlocks).</p>
<p>En caso de que la solución no se comportara de forma esperada, deberán poder explicar las causas y sus posibles rectificaciones.</p>
<h3 id="casos-de-prueba-en-vivo"><a class="header" href="#casos-de-prueba-en-vivo">Casos de prueba en vivo</a></h3>
<p>Durante la presentación se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia.</p>
<h3 id="informe-7"><a class="header" href="#informe-7">Informe</a></h3>
<p>El informe debe estar estructurado profesionalmente y debe poder dar cuenta de las decisiones tomadas para implementar la solución.</p>
<p>Se debe detallar en un diagrama, las entidades desarrolladas, las herramientas de concurrencia empleadas. Así como también los threads y formas de comunicación entre ellos. Se debe poder entender qué mensajes datos entre ellos y de qué forma.</p>
<h3 id="organización-del-código-10"><a class="header" href="#organización-del-código-10">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust (i.e. no utilizar unsafe)</p>
<h3 id="tests-automatizados-10"><a class="header" href="#tests-automatizados-10">Tests automatizados</a></h3>
<p>La presencia de tests automatizados que prueben diferentes casos, en especial sobre el uso de las herramientas de concurrencia es un plus.</p>
<h3 id="presentación-en-término-10"><a class="header" href="#presentación-en-término-10">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influye negativamente en la nota final.</p>
<h3 id="participación-individual"><a class="header" href="#participación-individual">Participación individual</a></h3>
<p>Si bien el trabajo es grupal, la nota es individual y la participación del alumno durante la presentación influye en su nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finales-julioagosto-2022"><a class="header" href="#finales-julioagosto-2022">Finales Julio/Agosto 2022</a></h1>
<p>Los exámenes finales del periodo julio/agosto 2022 serán de forma <strong>presencial</strong> en la sede de Paseo Colón, en las siguientes fechas:</p>
<p>9509 // 7559 Técnicas de Programación Concurrente I:</p>
<ul>
<li>martes 26/7 a las 18 hs</li>
<li>martes 2/8 a las 18 hs</li>
<li>martes 9/8 a las 18 hs</li>
<li>martes 16/8 a las 18 hs</li>
<li>jueves 25/8 a las 18 hs</li>
</ul>
<p>Se evaluará de forma conceptual los temas tratados especialmente en la segunda parte de la materia (esto incluye responder preguntas conceptuales, desarrollos teóricos del tema o incluso desarrollar algo de código fuente para ilustrar un tema o responder algo solicitado).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2do-cuatrimestre-2021"><a class="header" href="#2do-cuatrimestre-2021">2do Cuatrimestre 2021</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-11"><a class="header" href="#trabajo-práctico-11">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong> 26 de octubre de 2021</p>
<h2 id="introducción-11"><a class="header" href="#introducción-11">Introducción</a></h2>
<p><em>AlGlobo.com</em> es un nuevo sitio de venta de pasajes online.  Gracias al fin de la pandemia ha empezado a crecer fuertemente y necesitan escalar su proceso de reservas.</p>
<p>Para ello desean reemplazar una implementación monolítica actual con un microservicio en Rust que se encarge especificamente de este proceso.</p>
<h2 id="objetivo-11"><a class="header" href="#objetivo-11">Objetivo</a></h2>
<p>Deberán implementar una aplicación en Rust que modele el sistema de reservas de AlGobo.com. Los pedidos de reserva se leerán desde un archivo y el webservice de cada aerolínea se simulará con sleeps aleatorios, y su resultado utilizando también variables aleatorias (random).</p>
<h2 id="requerimientos-11"><a class="header" href="#requerimientos-11">Requerimientos</a></h2>
<p>El proceso de reserva se compone de la siguiente manera:</p>
<ul>
<li>El pedido de reserva ingresa al sistema e indica aeropuerto de origen, de destino, aerolínea preferida y si la reserva es por paquete o solo vuelo.</li>
<li>El pedido se debe enviar a la aerolínea correspondiente. Para ello se comunica con un webservice específico de la misma. Por motivos de rate limiting, cada webservice no puede realizar mas de  N pedidos concurrentes (es un límite configurable). Tener en cuenta que la cantidad de aerolíneas con las que se comunica el sistema debe poder crecer con un esfuerzo mínimo.</li>
<li>La aerolínea puede aceptar el pedido o recharzarlo. Si es rechazado, el sistema debe esperar X segundos para reintentar (el tiempo debe ser configurable).</li>
<li>En el caso de que la reserva sea por paquete, el pedido se debe enviar también al webservice de hoteles. El resultado final de la reserva entonces necesitará que ambos pedidos (hotel y aerolinea) se completen. Por suerte las reservas de hoteles nunca se rechazan.</li>
<li>El sistema debe mantener estadísticas de las rutas más solicitadas, que luego se utilizan para realizar ofertas. Para ello debe mantener un conteo de la cantidad de reservas realizadas de cada ruta y poder informar periódicamente las 10 más solicitadas.</li>
<li>Además el sistema mantendrá estadísticas operacionales. Para ello debe calcular el tiempo medio que toma una reserva desde que ingresa el pedido hasta que es finalmente aceptada.</li>
<li>Se debe escribir un archivo de log con las operaciones que se realizan y sus resultados.</li>
</ul>
<h3 id="parte-a"><a class="header" href="#parte-a">Parte A</a></h3>
<p>Implementar la aplicación utilizando las herramientas de concurrencia de la biblioteca standard de Rust vistas en clase: Mutex, RwLock, Semáforos (del crate std-semaphore), Channels, Barriers y Condvars.</p>
<h3 id="parte-b"><a class="header" href="#parte-b">Parte B</a></h3>
<p>Implementar la aplicación basada en el modelo de Actores, utilizando el framework Actix.</p>
<h3 id="puntos-extra"><a class="header" href="#puntos-extra">Puntos extra</a></h3>
<p>Utilizar Tokio HTTP y/o Actix web para recibir requests reales y Apache AB para generarlos en lugar de leerlos de un archivos.</p>
<h2 id="requerimientos-no-funcionales-11"><a class="header" href="#requerimientos-no-funcionales-11">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega-9"><a class="header" href="#entrega-9">Entrega</a></h2>
<p>La resolución del presente proyecto es en grupos de tres integrantes.</p>
<p>La entrega del proyecto comprende lo siguiente:</p>
<ul>
<li>Informe, se deberá presentar en forma digital (PDF) enviado por correo electrónico a la dirección: pdeymon@fi.uba.ar</li>
<li>El código fuente de la aplicación, que se entregará únicamente por e-mail. El código fuente debe estar estructurado en un proyecto de cargo, y se debe omitir el directorio target/ en la entrega. El informe a entregar debe contener los siguientes items:
<ul>
<li>Una explicación del diseño y de las decisiones tomadas para la implementación de la solución.</li>
<li>Detalle de resolución de la lista de tareas anterior.</li>
<li>Diagrama que refleje los threads, el flujo de comunicación entre ellos y los datos que intercambian.</li>
<li>Diagramas de entidades realizados (structs y demás).</li>
</ul>
</li>
</ul>
<h2 id="criterios-de-evaluación-1"><a class="header" href="#criterios-de-evaluación-1">Criterios de evaluación</a></h2>
<h3 id="presentación-principios-teóricos-y-defensa-de-bugs-potenciales-1"><a class="header" href="#presentación-principios-teóricos-y-defensa-de-bugs-potenciales-1">Presentación, principios teóricos y defensa de bugs potenciales</a></h3>
<p>Los alumnos presentarán el código de su solución en vivo en una reunión sincrónica, con foco en el uso de las diferentes herramientas de concurrencia. Deberán poder explicar desde los conceptos teóricos vistos en clase cómo se comportará potencialmente su solución ante problemas de concurrencia (por ejemplo ausencia de deadlocks).</p>
<p>En caso de que la solución no se comportara de forma esperada, deberán poder explicar las causas y sus posibles rectificaciones.</p>
<h3 id="casos-de-prueba-en-vivo-1"><a class="header" href="#casos-de-prueba-en-vivo-1">Casos de prueba en vivo</a></h3>
<p>Durante la presentación se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia.</p>
<h3 id="informe-8"><a class="header" href="#informe-8">Informe</a></h3>
<p>El informe debe estar estructurado profesionalmente y debe poder dar cuenta de las decisiones tomadas para implementar la solución.</p>
<p>Se debe detallar en un diagrama, las entidades desarrolladas, las herramientas de concurrencia empleadas. Así como también los threads y formas de comunicación entre ellos. Se debe poder entender qué mensajes datos entre ellos y de qué forma.</p>
<h3 id="organización-del-código-11"><a class="header" href="#organización-del-código-11">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust (i.e. no utilizar unsafe)</p>
<h3 id="tests-automatizados-11"><a class="header" href="#tests-automatizados-11">Tests automatizados</a></h3>
<p>La presencia de tests automatizados que prueben diferentes casos, en especial sobre el uso de las herramientas de concurrencia es un plus.</p>
<h3 id="presentación-en-término-11"><a class="header" href="#presentación-en-término-11">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influye negativamente en la nota final.</p>
<h3 id="participación-individual-1"><a class="header" href="#participación-individual-1">Participación individual</a></h3>
<p>Si bien el trabajo es grupal, la nota es individual y la participación del alumno durante la presentación influye en su nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-12"><a class="header" href="#trabajo-práctico-12">Trabajo Práctico</a></h1>
<p><strong>Fecha de Entrega:</strong> 14 de diciembre de 2021</p>
<h2 id="introducción-12"><a class="header" href="#introducción-12">Introducción</a></h2>
<p>Continuamos desarrollando el backend de <em>AlGlobo.com</em>. En este caso vamos a trabajar con el sistema de procesamiento de pagos.</p>
<h2 id="requerimientos-12"><a class="header" href="#requerimientos-12">Requerimientos</a></h2>
<p>El proceso de pagos se compone de la siguiente manera:</p>
<ul>
<li>Intervienen 4 entidades: AlGlobo.com, el banco, la aerolínea y el hotel.</li>
<li>Existe una cola de pagos a procesar que se lee desde un archivo.</li>
<li>AlGlobo.com debe coordinar el pago informando el monto a cobrar a cada entidad de forma concurrente.</li>
<li>Cada entidad puede aleatoriamente procesar correctamente el cobro o no.</li>
<li>Si alguna falla, se debe mantener la transaccionalidad y por lo tanto revertir o cancelar apropiadamente.</li>
<li>Las fallas se guardan en un archivo de fallas para su posterior procesamiento manual. Debe implementarse una utilidad que permita reintentar manualmente cada pedido fallado.</li>
<li>El sistema de AlGlobo.com es de misión crítica y por lo tanto debe mantener varias réplicas en línea listas para continuar el proceso, aunque solo una de ellas se encuentra activa al mismo tiempo. Para ello utiliza un algoritmo de elección de líder y mantiene sincronizado entre las réplicas la información del la transacción actual.</li>
</ul>
<h2 id="objetivo-12"><a class="header" href="#objetivo-12">Objetivo</a></h2>
<p>Deberán implementar un conjunto de aplicaciones en Rust que modele el sistema de procesamiento de pagos de AlGlobo.com.</p>
<p>Se debe implementar un proceso para cada una de las entidades intervinientes y estas se comunicarán entre sí por sockets.</p>
<p>Se debe poder simular la salida de servicio de cualquiera de los procesos y réplicas de forma aleatoria o voluntaria, mostrando que el sistema en su conjunto sigue funcionando.</p>
<h2 id="requerimientos-no-funcionales-12"><a class="header" href="#requerimientos-no-funcionales-12">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados o autorizados expresamente a pedido por la cátedra.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="entrega-10"><a class="header" href="#entrega-10">Entrega</a></h2>
<p>La resolución del presente proyecto es en grupos de tres integrantes.</p>
<p>La entrega del proyecto comprende lo siguiente:</p>
<ul>
<li>Informe, se deberá presentar en forma digital (PDF) enviado por correo electrónico a las direcciones: pdeymon@fi.uba.ar y ascarpinelli@fi.uba.ar</li>
<li>El código fuente de la aplicación, que se entregará únicamente por e-mail. El código fuente debe estar estructurado en un proyecto de cargo, y se debe omitir el directorio target/ en la entrega.</li>
<li>El informe a entregar debe contener los siguientes items:
<ul>
<li>Una explicación del diseño y de las decisiones tomadas para la implementación de la solución.</li>
<li>Detalle de resolución de la lista de tareas anterior.</li>
<li>Diagrama que refleje los threads, el flujo de comunicación entre ellos y los datos que intercambian.</li>
<li>Diagramas de entidades realizados (structs y demás).</li>
</ul>
</li>
</ul>
<h2 id="criterios-de-evaluación-2"><a class="header" href="#criterios-de-evaluación-2">Criterios de evaluación</a></h2>
<h3 id="presentación-principios-teóricos-y-defensa-de-bugs-potenciales-2"><a class="header" href="#presentación-principios-teóricos-y-defensa-de-bugs-potenciales-2">Presentación, principios teóricos y defensa de bugs potenciales</a></h3>
<p>Los alumnos presentarán el código de su solución en vivo en una reunión sincrónica, con foco en el uso de las diferentes herramientas de concurrencia. Deberán poder explicar desde los conceptos teóricos vistos en clase cómo se comportará potencialmente su solución ante problemas de concurrencia (por ejemplo ausencia de deadlocks).</p>
<p>En caso de que la solución no se comportara de forma esperada, deberán poder explicar las causas y sus posibles rectificaciones.</p>
<h3 id="casos-de-prueba-en-vivo-2"><a class="header" href="#casos-de-prueba-en-vivo-2">Casos de prueba en vivo</a></h3>
<p>Durante la presentación se someterá a la aplicación a diferentes casos de prueba que validen la correcta aplicación de las herramientas de concurrencia.</p>
<h3 id="informe-9"><a class="header" href="#informe-9">Informe</a></h3>
<p>El informe debe estar estructurado profesionalmente y debe poder dar cuenta de las decisiones tomadas para implementar la solución.</p>
<p>Se debe detallar en un diagrama, las entidades desarrolladas, las herramientas de concurrencia empleadas. Así como también los threads y formas de comunicación entre ellos. Se debe poder entender qué mensajes datos entre ellos y de qué forma.</p>
<h3 id="organización-del-código-12"><a class="header" href="#organización-del-código-12">Organización del código</a></h3>
<p>El código debe organizarse respetando los criterios de buen diseño y en particular aprovechando las herramientas recomendadas por Rust (i.e. no utilizar unsafe)</p>
<h3 id="tests-automatizados-12"><a class="header" href="#tests-automatizados-12">Tests automatizados</a></h3>
<p>La presencia de tests automatizados que prueben diferentes casos, en especial sobre el uso de las herramientas de concurrencia es un plus.</p>
<h3 id="presentación-en-término-12"><a class="header" href="#presentación-en-término-12">Presentación en término</a></h3>
<p>El trabajo deberá entregarse para la fecha estipulada. La presentación fuera de término sin coordinación con antelación con el profesor influye negativamente en la nota final.</p>
<h3 id="participación-individual-2"><a class="header" href="#participación-individual-2">Participación individual</a></h3>
<p>Si bien el trabajo es grupal, la nota es individual y la participación del alumno durante la presentación influye en su nota final.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finales-febreromarzo-2022"><a class="header" href="#finales-febreromarzo-2022">Finales Febrero/Marzo 2022</a></h1>
<p>Los exámenes finales del periodo febrero/marzo 2022 serán de forma <strong>presencial</strong> en la sede de Paseo Colón, en las siguientes fechas:</p>
<p>9509 // 7559 Técnicas de Programación Concurrente I:</p>
<ul>
<li>jueves 10/2 a las 18 hs</li>
<li>martes 15/2 a las 18 hs</li>
<li>martes 22/2 a las 18 hs</li>
<li>jueves 3/3 a las 18 hs</li>
<li>martes 8/3 a las 18 hs</li>
</ul>
<p>Se evaluará de forma conceptual los temas tratados especialmente en la segunda parte de la materia (esto incluye responder preguntas conceptuales, desarrollos teóricos del tema o incluso desarrollar algo de código fuente para ilustrar un tema o responder algo solicitado).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1er-cuatrimestre-2021"><a class="header" href="#1er-cuatrimestre-2021">1er Cuatrimestre 2021</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trabajo-práctico-1---1er-cuatrimestre-2021"><a class="header" href="#trabajo-práctico-1---1er-cuatrimestre-2021">Trabajo Práctico 1 - 1er Cuatrimestre 2021</a></h1>
<p><strong>Objetivo:</strong> Realizar un trabajo de investigación y desarrollo sobre un paper de uno de los temas tratados en la materia.</p>
<p><strong>Tareas:</strong></p>
<p>Seleccionar un paper de la lista siguiente.</p>
<p>Interpretarlo, relacionarlo con los temas que trabajamos en la materia.</p>
<p>Preparar una exposición en grupo para presentar frente a la clase.</p>
<p><strong>Fechas de la exposición:</strong> 1ro y 2 de junio.</p>
<h2 id="lista-de-papers"><a class="header" href="#lista-de-papers">Lista de Papers</a></h2>
<ul>
<li><strong>Modelo de actores:</strong> Adicionalmente, relacionarlo con el modelo de actores de Erlang.
<ul>
<li><a href="./tp1/Actor_Model_of_Computation_1008.1459v8.pdf">Actor Model of Computation</a></li>
<li><a href="./tp1/An_Actor-Based_Programming_System.pdf">An Actor-Based Programming System</a></li>
</ul>
</li>
<li><a href="./tp1/IJPP.pdf">Redes de Petri</a>.</li>
<li><a href="./tp1/Hoare78.pdf">Monitores</a></li>
</ul>
<h2 id="trabajo-presentados"><a class="header" href="#trabajo-presentados">Trabajo presentados</a></h2>
<ul>
<li>Grupo 1 - Redes de Petri: <a href="./tp1/presentaciones/grupo1_Redes_de_Petri.pdf">slides</a> - <a href="./tp1/presentaciones/grupo1_ejemplos_codigo.tar.bz2">ejemplos de código</a></li>
<li>Grupo 2 - Redes de Petri (ejemplos): <a href="./tp1/presentaciones/grupo2_GENERAL.pdf">slides</a> - <a href="./tp1/presentaciones/grupo2_xml_red.tar.bz2">ejemplos XML</a> para usar con el software <a href="http://pipe2.sourceforge.net/">Petri net Editor 2</a>. Repositorio de <a href="https://github.com/crpistillo/philosophers">problema de los Filósofos</a>.</li>
<li>Grupo 4 - Redes de Petri: <a href="./tp1/presentaciones/grupo4_TP1_Redes_de_Petri.pdf">slides</a></li>
<li>Grupo 5 - Paper Dijkstra: <a href="./tp1/presentaciones/grupo5_Presentacion_Paper_Dijkstra_cap_3y4-JoregAnca82399.pdf">slides</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buscador-de-sinónimos-rústico---1er-cuatrimestre-2021"><a class="header" href="#buscador-de-sinónimos-rústico---1er-cuatrimestre-2021">Buscador de Sinónimos Rústico - 1er Cuatrimestre 2021</a></h1>
<p><strong>Fecha de entrega:</strong> 29 de junio antes de las 19 hs.</p>
<h2 id="objetivo-13"><a class="header" href="#objetivo-13">Objetivo</a></h2>
<p>El presente trabajo práctico tiene como objetivo implementar un software buscador de sinónimos de palabras.</p>
<p>Para ello se realizarán peticiones de varios sitios de Internet que ofrecen este servicio.</p>
<h2 id="requerimientos-funcionales"><a class="header" href="#requerimientos-funcionales">Requerimientos Funcionales</a></h2>
<p>Se debe implementar un software para ser ejecutado en la consola de comandos que busque sinónimos de palabras en distintos sitios de Internet.</p>
<p>Se usarán los siguientes sitios que permiten buscar sinóminos de palabras en inglés:</p>
<ul>
<li><a href="https://thesaurus.yourdictionary.com/">https://thesaurus.yourdictionary.com/</a></li>
<li><a href="https://www.thesaurus.com/browse/">https://www.thesaurus.com/browse/</a></li>
<li><a href="https://www.merriam-webster.com/thesaurus/">https://www.merriam-webster.com/thesaurus/</a></li>
</ul>
<p>Por ejemplo, para buscar sinónimos de "car", se debe invocar:</p>
<ul>
<li><a href="https://thesaurus.yourdictionary.com/car">https://thesaurus.yourdictionary.com/car</a></li>
<li><a href="https://www.thesaurus.com/browse/car">https://www.thesaurus.com/browse/car</a></li>
<li><a href="https://www.merriam-webster.com/thesaurus/car">https://www.merriam-webster.com/thesaurus/car</a></li>
</ul>
<p><em>Nota:</em> Estos tres proveedores de sinónimos son los que disponemos hoy en día. En un futuro se debería poder incorporar fácilmente nuevos proveedores, el único trabajo que se debería hacer es el parser específico de la respuesta, para extraer las palabras.</p>
<p>El programa debe recibir por parámetro la ruta a un archivo que contiene una lista de palabras sobre las que se quieren buscar sinónimos (una palabra por línea del archivo) y los parámetros de configuración de la ejecución, como se explica más adelante.</p>
<p>Para realizar las consultas de los sinónimos, se debe realizar un pedido (<strong>request</strong>) HTTP a cada una de las direcciones. Para eso, se debe utilizar el crate <a href="https://docs.rs/reqwest/">reqwest</a>. Este crate debe ser usado en forma bloqueante (<a href="https://docs.rs/reqwest/0.11.3/reqwest/blocking/index.html">ver blocking</a>).</p>
<p>Debe procesarse el texto de respuesta de cada una de las invocaciones (string) para extraer las palabras que son sinónimos. Para esto, debe utilizarse los <a href="https://doc.rust-lang.org/std/string/struct.String.html">métodos de <strong>String</strong></a> de la std del lenguaje.</p>
<p>Los resultados deben mostrarse de forma consolidada, sin repetir los resultados (en caso de que se encuentren en más de un sitio). Al lado de cada resultado se debe indicar entre paréntesis, en cuántos sitios apareció ese valor.</p>
<p>Las parámetros que se debe poder configurar son:</p>
<ul>
<li>Cantidad máxima de pedidos a los sitios web (requests) a procesar de forma concurrente.</li>
<li>Tiempo de espera mínimo entre dos invocaciones al mismo sitio de sinónimos.</li>
</ul>
<p>Se debe divir el programa en hilos de ejecución (threads) que sean lo más chico posibles y con una responsabilidad acotada, que permitan realizar las diversas tareas de forma concurrente.</p>
<p>Se debe escribir un archivo de <strong>log</strong> con las operaciones que se realizan y sus resultados.</p>
<h3 id="parte-a-1"><a class="header" href="#parte-a-1">Parte A</a></h3>
<p>Implementar el programa utilizando las herramientas de concurrencia de la biblioteca standard de Rust vistas en clase: Mutex, RwLock, Semáforos (del crate <a href="https://docs.rs/std-semaphore/">std-semaphore</a>), Channels, Barriers y Condvars.</p>
<h3 id="parte-b-1"><a class="header" href="#parte-b-1">Parte B</a></h3>
<p>Implementar el programa basado en el modelo de Actores, utilizando el framework <a href="https://actix.rs/">Actix</a>.</p>
<h2 id="requerimientos-no-funcionales-13"><a class="header" href="#requerimientos-no-funcionales-13">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>No se permite utilizar <strong>crates</strong> externos, salvo los explícitamente mencionados.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="tareas-a-realizar"><a class="header" href="#tareas-a-realizar">Tareas a Realizar</a></h2>
<p>A continuación se listan las tareas a realizar para completar el desarrollo del proyecto:</p>
<ul>
<li>Dividir el proyecto en threads. El objetivo es lograr que la simulación esté conformada por un conjunto de hilos de ejecución que sean lo más sencillos posible.</li>
<li>Una vez obtenida la división en threads, establecer un esquema de comunicación entre ellos teniendo en cuenta los requerimientos de la aplicación. ¿Qué threads se comunican entre sı́? ¿Qué datos necesitan compartir para poder trabajar?</li>
<li>Realizar la codificación de la aplicación. El código fuente debe estar documentado.</li>
<li>Implementar tests unitarios de las funciones que considere relevantes.</li>
</ul>
<h2 id="entrega-11"><a class="header" href="#entrega-11">Entrega</a></h2>
<p>La resolución del presente proyecto es en grupos de tres integrantes.</p>
<p>La entrega del proyecto comprende lo siguiente:</p>
<ul>
<li>Informe, se deberá presentar en forma digital (PDF) enviado por correo electrónico a la dirección: pdeymon@fi.uba.ar</li>
<li>El código fuente de la aplicación, que se entregará únicamente por e-mail. El código fuente debe estar estructurado en un proyecto de cargo, y se debe omitir el directorio target/ en la entrega. El informe a entregar debe contener los siguientes items:
<ul>
<li>Una explicación del diseño y de las decisiones tomadas para la implementación de la solución.</li>
<li>Detalle de resolución de la lista de tareas anterior.</li>
<li>Diagrama que refleje los threads, el flujo de comunicación entre ellos y los datos que intercambian.</li>
<li>Diagramas de entidades realizados (structs y demás).</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-rústica---1er-cuatrimestre-2021"><a class="header" href="#blockchain-rústica---1er-cuatrimestre-2021">Blockchain Rústica - 1er Cuatrimestre 2021</a></h1>
<p><strong>Fecha de entrega:</strong> 27 de julio antes de las 19 hs.</p>
<h2 id="objetivo-14"><a class="header" href="#objetivo-14">Objetivo</a></h2>
<p>El objetivo del presente trabajo consiste en aplicar los conceptos estudiados de Concurrencia Distribuida para implementar una funcionalidad de <em>blockchain</em> simplificada.</p>
<h2 id="introducción-13"><a class="header" href="#introducción-13">Introducción</a></h2>
<p>La <strong>blockchain</strong> es una forma de almacenar información, que consiste en un registro único, consensuado y distribuido en varios nodos de una red.  A grandes rasgos su estructura es la de una cadena de bloques que están encadenados de forma sucesiva. Cada bloque contiene la información (a partir de un <em>hash</em>) del bloque que lo precede.</p>
<p>Se usa para almacenar información que no puede ser alterada, como es el caso de transacciones de criptomonedas. Se puede pensar como el libro contable donde se registra cada una de esas transacciones.</p>
<h2 id="requerimientos-funcionales-1"><a class="header" href="#requerimientos-funcionales-1">Requerimientos Funcionales</a></h2>
<p>Se debe implementar una versión reducida y simplificada de una blockchain que permita almacenar las calificaciones de los estudiantes de la materia. Esta información debe poder ser escrita y leída.</p>
<p>Se debe respetar que cada registro sea un bloque de la blockchain y, por lo tanto, tenga información referente al bloque o los bloques precedentes.</p>
<p>Esta implementación debe funcionar como un conjunto de programas en ejecución que se comunican entre sí utilizando sockets sobre el protocolo TCP/IP. Se debe utilizar Sockets de la biblioteca standar del lenguaje Rust.</p>
<p>Para el agregado de un bloque nuevo, un nodo debe poder realizar las operaciones de forma <strong>exclusiva</strong>. Para esto, se debe implementar alguno de los algoritmos estudiados en la materia:</p>
<ul>
<li>Algoritmo Centralizado</li>
<li>Algoritmo Distribuido</li>
<li>Algoritmo Token Ring</li>
</ul>
<p>Una vez que se agrega un bloque nuevo, un nodo que cumple el rol de líder debe comunicar la operación a todos los demás. Para la elección del líder se debe implementar alguno de los algoritmos estudiados:</p>
<ul>
<li>Algoritmo de Bully</li>
<li>Algoritmo Ring</li>
</ul>
<p>Se debe poder simular la salida de servicio de los nodos de forma aleatoria o voluntaria. En particular, se debe poder observar que si sale de servicio el nodo que actúa como líder, se debe reiniciar el algoritmo de elección para reemplazarlo con uno nuevo.</p>
<h2 id="requerimientos-no-funcionales-14"><a class="header" href="#requerimientos-no-funcionales-14">Requerimientos no funcionales</a></h2>
<p>Los siguientes son los requerimientos no funcionales para la resolución de los ejercicios:</p>
<ul>
<li>El proyecto deberá ser desarrollado en lenguaje Rust, usando las herramientas de la biblioteca estándar.</li>
<li>No se permite utilizar <strong>crates</strong> externos.</li>
<li>El código fuente debe compilarse en la última versión stable del compilador y no se permite utilizar bloques unsafe.</li>
<li>El código deberá funcionar en ambiente Unix / Linux.</li>
<li>El programa deberá ejecutarse en la línea de comandos.</li>
<li>La compilación no debe arrojar <strong>warnings</strong> del compilador, ni del linter <strong>clippy</strong>.</li>
<li>Las funciones y los tipos de datos (<strong>struct</strong>) deben estar documentadas siguiendo el estándar de <strong>cargo doc</strong>.</li>
<li>El código debe formatearse utilizando <strong>cargo fmt</strong>.</li>
<li>Cada tipo de dato implementado debe ser colocado en una unidad de compilación (archivo fuente) independiente.</li>
</ul>
<h2 id="tareas-a-realizar-1"><a class="header" href="#tareas-a-realizar-1">Tareas a Realizar</a></h2>
<p>A continuación se listan las tareas a realizar para completar el desarrollo del proyecto:</p>
<ul>
<li>Dividir el proyecto en procesos y threads. El objetivo es lograr procesos que cumplan un objetivo específico y que estos se conformen por un conjunto de hilos de ejecución que sean lo más sencillos posible.</li>
<li>Una vez obtenida la división en threads, establecer un esquema de comunicación entre ellos teniendo en cuenta los requerimientos de la aplicación. ¿Qué threads se comunican entre sı́? ¿Qué datos necesitan compartir para poder trabajar?</li>
<li>Realizar la codificación de la aplicación. El código fuente debe estar documentado.</li>
<li>Implementar tests unitarios de las funciones que considere relevantes.</li>
</ul>
<h2 id="entrega-12"><a class="header" href="#entrega-12">Entrega</a></h2>
<p>La resolución del presente proyecto es en grupos de tres integrantes.</p>
<p>La entrega del proyecto comprende lo siguiente:</p>
<ul>
<li>Informe, se deberá presentar en forma digital (PDF) enviado por correo electrónico a la dirección: pdeymon@fi.uba.ar</li>
<li>El código fuente de la aplicación, que se entregará únicamente por e-mail. El código fuente debe estar estructurado en un proyecto de cargo, y se debe omitir el directorio target/ en la entrega. El informe a entregar debe contener los siguientes items:
<ul>
<li>Una explicación del diseño y de las decisiones tomadas para la implementación de la solución.</li>
<li>Detalle de resolución de la lista de tareas anterior.</li>
<li>Diagrama que refleje los threads, el flujo de comunicación entre ellos y los datos que intercambian.</li>
<li>Diagramas de entidades realizados (structs y demás).</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examen-final"><a class="header" href="#examen-final">Examen Final</a></h1>
<p>La modalidad del examen final será de tipo remota.
El estudiante debe escoger uno de los papers / artículos de la lista de abajo y preparar una exposición del
mismo relacionada con los tema de la materia.</p>
<p>Asimismo, se evaluará con preguntas haciendo énfasis en los temas de <strong>Concurrencia Distribuida</strong>
(ver desde la clase 8 en adelante).</p>
<p>Las fechas de examen están publicadas en la plataforma SIU Guaraní.
Por favor, luego de inscribirse, enviar un correo electrónico para combinar la reunión por Google Meet.</p>
<p>Lista de papers:</p>
<ul>
<li><a href="./papers_final/gfs.pdf">The Google File System</a></li>
<li><a href="./papers_final/20120829-LinuxCon-MDB-txt.pdf">Life After BerkeleyDB: OpenLDAP's Memory-Mapped Database</a></li>
<li><a href="./papers_final/bitcoin.pdf">Bitcoin: A Peer-to-Peer Electronic Cash System</a></li>
<li><a href="./papers_final/byz.pdf">The Byzantine Generals Problem</a></li>
<li><a href="./papers_final/Kapritsos.pdf">Scalable agreement: Toward ordering as a service</a></li>
<li><a href="./papers_final/zaharia-spark.pdf">Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing</a></li>
<li><a href="https://dzone.com/articles/tick-or-tock-keeping-time-and-order-in-distributed-1">Tick or Tock? Keeping Time and Order in Distributed Databases</a></li>
<li><a href="./papers_final/10.1.1.41.7628.pdf">A Note on Distributed Computing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="material-adicional"><a class="header" href="#material-adicional">Material Adicional</a></h1>
<h2 id="videos"><a class="header" href="#videos">Videos</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=7ENFeb-J75k">Multithreading Code - Computerphile</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bibliografía"><a class="header" href="#bibliografía">Bibliografía</a></h1>
<p>La bibliografía recomendada de la materia es la siguiente</p>
<ul>
<li>
<p><strong>Rust</strong></p>
<ul>
<li>Principles of Concurrent and Distributed Programming, M. Ben-Ari, Segunda edición (capítulos 1, 2, 6 y 7)</li>
<li>Operating System Concepts, Ninth Edition, Abraham Silberschatz, Greg Gagne, and Peter Baer Galvin, Cap. 4.</li>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a></li>
</ul>
</li>
<li>
<p><strong>Fork Join</strong></p>
<ul>
<li>Parallelization in Rust with fork-join and friends. Creating the ForkJoin framework, Master's thesis in Computer Science and Engineering. Linus Färnstrand</li>
<li><a href="https://docs.rs/crayon/latest/crayon/">Documentacion Crayon</a></li>
<li><a href="https://docs.rs/crossbeam/latest/crossbeam/">Documentacion CrossBeam</a></li>
<li><a href="https://ia600703.us.archive.org/30/items/AMultiprocessorSystemDesignConway1963/A%20Multiprocessor%20System%20Design%20%28Conway%2C%201963%29.pdf">A Multiprocessor System Design, M.E. Conway, 1963</a></li>
<li><a href="https://static.googleusercontent.com/media/research.google.com/es//archive/mapreduce-osdi04.pdf">MapReduce: Simplified Data Processing on Large Clusters, Jeffrey Dean and Sanjay Ghemawat, 2014</a></li>
<li><a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36632.pdf">Dremel: Interactive Analysis of Web-Scale Datasets S. Melnik et al., 2010</a></li>
</ul>
</li>
<li>
<p><strong>Async</strong></p>
<ul>
<li>Programming Rust: Fast, Safe Systems Development, 2nd Edition, Jim Blandy, Jason Orendorff, Leonora F. S. Tindall. 2021.</li>
<li><a href="https://rust-lang.github.io/async-book/">Asynchronous Programming in Rust</a></li>
</ul>
</li>
<li>
<p><strong>Mutex</strong></p>
<ul>
<li>Principles of Concurrent and Distributed Programming, M. Ben-Ari, Segunda edición (capítulos 1 y 2)</li>
<li>Unix Network Programming, Interprocess Communications, W. Richard Stevens, segunda edición"</li>
</ul>
</li>
<li>
<p><strong>Semaphores, Barriers Condvars</strong></p>
<ul>
<li>The Design of the Unix Operating System, Maurice Bach</li>
<li>Sistemas Operativos Modernos, Tanenbaum, Capítulo 2.3</li>
<li><a href="https://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf">The Little Book of Semaphores, Allen B. Downey</a></li>
<li>Monitors: An Operating System Structuring Concept, C.A.R. Hoare, Communications of the ACM, 1974</li>
<li><a href="https://dl.acm.org/doi/10.1145/362759.362813">Concurrent control with ""readers"" and ""writers""</a></li>
</ul>
</li>
<li>
<p><strong>Channels and Actors</strong></p>
<ul>
<li>Principles of Concurrent and Distributed Programming, M. Ben-Ari, Segunda edición (capítulos 6)</li>
<li>The Complete Rust Programming Reference Guide, Rahul Sharma, Vesa Kaihlavirta, Claus Matzinger.
An Actor-Based Programming System, Roy J. Byrd, Stephen E. Smith, S. Peter de Jong. IBM Thomas J. Watson Research Center, Yorktown Heights, New York 10598</li>
<li>Seven Concurrency Models in Seven Weeks: When Threads Unravel (The Pragmatic Programmers), Paul Butcher</li>
<li><a href="https://actix.rs/book/actix/">Actix</a></li>
<li><a href="https://www.ijcai.org/Proceedings/73/Papers/027B.pdf">A Universal Modular ACTOR Formalism for Artificial Intelligence. C. Hewitt, P. Bishop, and R. Steiger. IJCAI , page 235-245. William Kaufmann, (1973 )</a></li>
<li><a href="https://www.cs.utexas.edu/users/misra/scannedPdf.dir/DrinkingPhil.pdf">The Drinking Philosophers Problem. Chandy, K.M.; Misra, J. (1984). ACM Transactions on Programming Languages and Systems</a></li>
</ul>
</li>
<li>
<p><strong>Sockets</strong></p>
<ul>
<li>Distributed Operating Systems, Andrew S. Tanenbaum, capítulo 3</li>
<li>Computer Networks, Andrew S. Tanenbaum y David J. Wetherall, quinta edición</li>
<li>Unix Network Programming - Volume 1 - The Sockets Networking API, Richard Stevens, tercera edición</li>
<li>Ricart, Glenn; Agrawala, Ashok K. (1 January 1981). ""An optimal algorithm formutual exclusion in computer networks"". Communications of the ACM. 24 (1):9–17 https://dl.acm.org/doi/abs/10.1145/358527.358537</li>
<li>Tanenbaum. Distributed Systems: Principles and paradigmns. Capitulo 6 "</li>
</ul>
</li>
<li>
<p><strong>Elección de líder</strong></p>
<ul>
<li>Distributed Operating Systems, Andrew S. Tanenbaum, capítulo 3</li>
<li>Computer Networks, Andrew S. Tanenbaum y David J Wetherall, quinta edición</li>
<li>The Complete Rust Programming Reference Guide, Rahul Sharma, Vesa Kaihlavirta, Claus Matzinger.</li>
<li>Hector Garcia-Molina, Elections in a Distributed Computing System, IEEE Transactions on Computers, Vol. C-31, No. 1, January (1982) 48–59</li>
<li>Tanenbaum. Distributed Systems: Principles and paradigmns. Capitulo 6"</li>
</ul>
</li>
<li>
<p><strong>Distributed Transactions</strong></p>
<ul>
<li>Distributed Operating Systems, Andrew S. Tanenbaum, capítulo 3</li>
<li>Computer Networks, Andrew S. Tanenbaum y David J. Wetherall, quinta edición</li>
<li>Distributed Systems: Principles and Paradigms. Tanenbaum &amp; Van Steem, Capitulo 8"</li>
<li>Design and Analysis of Distributed Algorithms, Nicola Santoro</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
